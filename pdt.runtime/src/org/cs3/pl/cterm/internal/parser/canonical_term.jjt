/**
* JJTree file
*/

options {
  JDK_VERSION = "1.4";
  STATIC=false;
  NODE_USES_PARSER=true;
  NODE_PACKAGE="org.cs3.pl.cterm.internal.parser";
  NODE_PREFIX="AST";
  VISITOR=true;
  MULTI=true;
  DEBUG_PARSER=false;
  DEBUG_LOOKAHEAD=false;
  DEBUG_TOKEN_MANAGER=false;  
  NODE_SCOPE_HOOK=true;
  LOOKAHEAD=1;

  
}
 
PARSER_BEGIN(CanonicalTermParser) 
package org.cs3.pl.cterm.internal.parser;

import java.io.FileNotFoundException;
import java.io.InputStream;
import java.util.ArrayList;
import java.util.List;


public class CanonicalTermParser {
	
	private List errors = new ArrayList();
	
	public List getErrors() {
		return errors;
	}
	
		void jjtreeOpenNodeScope(Node n)
    {
    	Token t = getToken(1);
    	//System.err.println("open node of type "+PrologTermParserTreeConstants.jjtNodeName[((SimpleNode)n).id]);
    	//System.err.prinln("   first token: "+t.image+" at line "+t.beginLine+", column "+t.beginColumn+".");
      ((SimpleNode)n).setFirstToken(t);
      
    }

    void jjtreeCloseNodeScope(Node n)
    {
      Token t = getToken(0);
    	//System.err.prinln("closing node of type "+n);
    	//System.err.prinln("   last token: "+t.image+" at line "+t.beginLine+", column "+t.beginColumn+".");      
      ((SimpleNode)n).setLastToken(t);
      
      
	  
	  	//need to "manualy" figure out the start token, as node scope hooks are
		//called "to late" for nodes like ASTInfixTerm 
		//if the nodes children have already been poped, this should work:
		SimpleNode s = (SimpleNode)n;
		if(s.jjtGetNumChildren()>0){
			 SimpleNode firstChild = (SimpleNode)s.jjtGetChild(0);
			 s.setFirstToken(firstChild.getFirstToken());
		}
		//System.err.println("created: "+ s+" : "+s.getImage());
		
		
 	  
	  }

	
	public void error_skipto(int kind) {
	  ParseException e = generateParseException();  
	  errors.add(e);
	  Token t;
	  do {
	    t = getNextToken();
	  } while (t.kind != kind && t.kind != EOF);
	}

public static void main(String args[]) throws FileNotFoundException {
        InputStream stream = null;
        if(args==null||args.length==0){
            //System.err.println("Reading from standard input...");
            stream=System.in;
        }
        else{
                return;
        }
    CanonicalTermParser t = new CanonicalTermParser(stream);
    try {
      t.Term();
      Node n = t.getASTRoot();
      
      System.err.println("Thank you.");
    } catch (Exception e) {
      System.err.println("Oops.");
      System.err.println(e.getMessage());
      e.printStackTrace();
    }
  }
  public Node getASTRoot(){
		return  jjtree.rootNode();
	}
  
}
PARSER_END(CanonicalTermParser)

SKIP :
{
  " "
| "\t"
| "\n"
| "\r"
| <"//" (~["\n","\r"])* ("\n"|"\r"|"\r\n")>
| <"/*" (~["*"])* "*" (~["/"] (~["*"])* "*")* "/">
}


TOKEN : /* SEPARATORS */
{
    < LPAREN: "(" > 
|   < RPAREN: ")" > 
|   < COMMA: "," >
|   < DOT: "." >

}


TOKEN : /* IDENTIFIERS */
{
  < ATOM_IDENTIFIER: <LC_LETTER> (<LETTER>|<DIGIT>)* >
| < VARIABLE_IDENTIFIER: <UC_LETTER> (<LETTER>|<DIGIT>)* >
|  < #LETTER: <UC_LETTER>|<LC_LETTER> >
|  < #LC_LETTER: ["a"-"z"] >
|  < #UC_LETTER: ["_","A"-"Z"] >
|  < #DIGIT: ["0"-"9"] >
}

TOKEN : /* LITERALS */
{  
  < DECIMAL_LITERAL: ("0'" ~[])|(["0"-"9"] (["0"-"9"])*) >
|  < BIN_LITERAL: ["0"-"9"] "b" ["0"-"1"] (["0"-"1"])* >
|  < OCT_LITERAL: ["0"-"9"] "o" ["0"-"7"] (["0"-"7"])* >
|  < HEX_LITERAL: ["0"-"9"] "x" ["0"-"9","A"-"F","a"-"f"] (["0"-"9","A"-"F","a"-"f"])* >
|  < FLOATING_POINT_LITERAL:
       	(["0"-"9"])+ "." (["0"-"9"])+ (<EXPONENT>)? 
      | (["0"-"9"])+ <EXPONENT> 
      | (["0"-"9"])+ (<EXPONENT>)? 
  >
| < #EXPONENT: ["e","E"] (["+","-"])? (["0"-"9"])+ >
| < QUOTED_ATOM:
      "'"
      (   (~["\'","\\","\n","\r"])
        | ("\\"
            ( ["n","t","b","r","f","\\","'","\""]
            )
          )
        | ("''")
      )*
      "'" 
  >


}



void Term()#void:{}
{
	LOOKAHEAD(Atom() "(") Compound()
	|Atom()
	|Number()	
}

void Atom():{}
{
	<ATOM_IDENTIFIER>|<QUOTED_ATOM>
}

void Variable():{}
{
	<VARIABLE_IDENTIFIER>|<QUOTED_ATOM>
}


void Compound():{}
{
	Atom()
	<LPAREN>
	Term()
	(		
		<COMMA>
		Term()
	)*
	<RPAREN>
}

void Number() #void:{}
{
	Integer()|Float()
}

void Integer() : {}
{
  <DECIMAL_LITERAL>|<BIN_LITERAL>|<OCT_LITERAL>|<HEX_LITERAL>
}

void Float() :{}
{
	<FLOATING_POINT_LITERAL>
}