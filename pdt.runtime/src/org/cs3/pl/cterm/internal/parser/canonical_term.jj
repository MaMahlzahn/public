/*@bgen(jjtree) Generated By:JJTree: Do not edit this line. ./canonical_term.jj */
/*@egen*//**
* JJTree file
*/

options {
  JDK_VERSION = "1.4";
  STATIC=false;                                                                                                                                    
  DEBUG_PARSER=false;
  DEBUG_LOOKAHEAD=false;
  DEBUG_TOKEN_MANAGER=false;                           
  LOOKAHEAD=1;

  
}
 
PARSER_BEGIN(CanonicalTermParser) 
package org.cs3.pl.cterm.internal.parser;

import java.io.FileNotFoundException;
import java.io.InputStream;
import java.util.ArrayList;
import java.util.List;


public class CanonicalTermParser/*@bgen(jjtree)*/implements CanonicalTermParserTreeConstants/*@egen*/ {/*@bgen(jjtree)*/
  protected JJTCanonicalTermParserState jjtree = new JJTCanonicalTermParserState();

/*@egen*/
	
	private List errors = new ArrayList();
	
	public List getErrors() {
		return errors;
	}
	
		void jjtreeOpenNodeScope(Node n)
    {
    	Token t = getToken(1);
    	//System.err.println("open node of type "+PrologTermParserTreeConstants.jjtNodeName[((SimpleNode)n).id]);
    	//System.err.prinln("   first token: "+t.image+" at line "+t.beginLine+", column "+t.beginColumn+".");
      ((SimpleNode)n).setFirstToken(t);
      
    }

    void jjtreeCloseNodeScope(Node n)
    {
      Token t = getToken(0);
    	//System.err.prinln("closing node of type "+n);
    	//System.err.prinln("   last token: "+t.image+" at line "+t.beginLine+", column "+t.beginColumn+".");      
      ((SimpleNode)n).setLastToken(t);
      
      
	  
	  	//need to "manualy" figure out the start token, as node scope hooks are
		//called "to late" for nodes like ASTInfixTerm 
		//if the nodes children have already been poped, this should work:
		SimpleNode s = (SimpleNode)n;
		if(s.jjtGetNumChildren()>0){
			 SimpleNode firstChild = (SimpleNode)s.jjtGetChild(0);
			 s.setFirstToken(firstChild.getFirstToken());
		}
		//System.err.println("created: "+ s+" : "+s.getImage());
		
		
 	  
	  }

	
	public void error_skipto(int kind) {
	  ParseException e = generateParseException();  
	  errors.add(e);
	  Token t;
	  do {
	    t = getNextToken();
	  } while (t.kind != kind && t.kind != EOF);
	}

public static void main(String args[]) throws FileNotFoundException {
        InputStream stream = null;
        if(args==null||args.length==0){
            //System.err.println("Reading from standard input...");
            stream=System.in;
        }
        else{
                return;
        }
    CanonicalTermParser t = new CanonicalTermParser(stream);
    try {
      t.Term();
      Node n = t.getASTRoot();
      
      System.err.println("Thank you.");
    } catch (Exception e) {
      System.err.println("Oops.");
      System.err.println(e.getMessage());
      e.printStackTrace();
    }
  }
  public Node getASTRoot(){
		return  jjtree.rootNode();
	}
  
}
PARSER_END(CanonicalTermParser)

SKIP :
{
  " "
| "\t"
| "\n"
| "\r"
| <"//" (~["\n","\r"])* ("\n"|"\r"|"\r\n")>
| <"/*" (~["*"])* "*" (~["/"] (~["*"])* "*")* "/">
}


TOKEN : /* SEPARATORS */
{
    < LPAREN: "(" > 
|   < RPAREN: ")" > 
|   < COMMA: "," >
|   < DOT: "." >
|   < LSQB: "[" >
|   < RSQB: "]" >
|	< CUT: "!" >
}


TOKEN : /* IDENTIFIERS */
{
  < ATOM_IDENTIFIER: (<LC_LETTER>|<GRAPHIC>) (<LETTER>|<DIGIT>|<GRAPHIC>)* >
| < VARIABLE_IDENTIFIER: <UC_LETTER> (<LETTER>|<DIGIT>)* >
|  < #LETTER: <UC_LETTER>|<LC_LETTER> >
|  < #LC_LETTER: ["a"-"z"]|<UNICODE_LETTER> >
|  < #UNICODE_LETTER:  ["\u00c0" - "\u1fff"]| ["\u3040" - "\ud7ff"]| ["\ue000" - "\uffef"]>
|  < #GRAPHIC : [";","$","#","&","*", "+" ,"-", "." ,"/" ,":" ,"<", "=", ">", "?", "@", "\\", "^", "~"] 
	             |["\u00a1" - "\u00bf"]| [ "\u2010" - "\u303f"] >
|  < #UC_LETTER: ["_","A"-"Z"] >
|  < #DIGIT: ["0"-"9"] >
}

TOKEN : /* LITERALS */
{  
  < DECIMAL_LITERAL: ("0'" (<LETTER>|<DIGIT>|<GRAPHIC>))|(["0"-"9"] (["0"-"9"])*) >
|  < BIN_LITERAL: ["0"-"9"] "b" ["0"-"1"] (["0"-"1"])* >
|  < OCT_LITERAL: ["0"-"9"] "o" ["0"-"7"] (["0"-"7"])* >
|  < HEX_LITERAL: ["0"-"9"] "x" ["0"-"9","A"-"F","a"-"f"] (["0"-"9","A"-"F","a"-"f"])* >
|  < FLOATING_POINT_LITERAL:
       	(["0"-"9"])+ "." (["0"-"9"])+ (<EXPONENT>)? 
      | (["0"-"9"])+ <EXPONENT> 
      | (["0"-"9"])+ (<EXPONENT>)? 
  >
| < #EXPONENT: ["e","E"] (["+","-"])? (["0"-"9"])+ >
| < QUOTED_ATOM:
      "'"
      (   (~["\'","\\","\n","\r"])
        | ("\\"
            ( ["n","t","b","r","f","\\","'","\""]
            )
          )
        | ("''")
      )*
      "'" 
  >
| < QUOTED_STRING:
      "\""
      (   (~["\"","\\","\n","\r"])
        | ("\\"
            ( ["n","t","b","r","f","\\","'","\""]
            )
          )
        | ("''")
      )*
      "\"" 
  >

}

void Start()     :{}
{
	Term()
	< EOF >
}

void Term()     :{}
{
	
	LOOKAHEAD(Atom() "(") Compound()
	|String()
	|Atom()
	|Number()	
	|Nil()
	|Variable()
	
}

void Atom():{/*@bgen(jjtree) Atom */
  ASTAtom jjtn000 = new ASTAtom(this, JJTATOM);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) Atom */
        try {
/*@egen*/
	<ATOM_IDENTIFIER>|<QUOTED_ATOM>|<CUT>/*@bgen(jjtree)*/
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
            jjtreeCloseNodeScope(jjtn000);
          }
        }
/*@egen*/
}

void Nil():{/*@bgen(jjtree) Nil */
  ASTNil jjtn000 = new ASTNil(this, JJTNIL);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) Nil */
        try {
/*@egen*/
	<LSQB><RSQB>/*@bgen(jjtree)*/
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
            jjtreeCloseNodeScope(jjtn000);
          }
        }
/*@egen*/
}

void Variable():{/*@bgen(jjtree) Variable */
  ASTVariable jjtn000 = new ASTVariable(this, JJTVARIABLE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) Variable */
        try {
/*@egen*/
	<VARIABLE_IDENTIFIER>/*@bgen(jjtree)*/
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
            jjtreeCloseNodeScope(jjtn000);
          }
        }
/*@egen*/
}


void Compound():{/*@bgen(jjtree) Compound */
  ASTCompound jjtn000 = new ASTCompound(this, JJTCOMPOUND);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) Compound */
        try {
/*@egen*/
	Atom()
	<LPAREN>
	Term()
	(		
		<COMMA>
		Term()
	)*
	<RPAREN>/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
            jjtreeCloseNodeScope(jjtn000);
          }
        }
/*@egen*/
}

void Number()      :{}
{
	Integer()|Float()
}

void Integer() : {/*@bgen(jjtree) Integer */
  ASTInteger jjtn000 = new ASTInteger(this, JJTINTEGER);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) Integer */
  try {
/*@egen*/
  <DECIMAL_LITERAL>|<BIN_LITERAL>/*@bgen(jjtree)*/
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
      jjtreeCloseNodeScope(jjtn000);
    }
  }
/*@egen*//*|<OCT_LITERAL>|<HEX_LITERAL>*/
}

void Float() :{/*@bgen(jjtree) Float */
  ASTFloat jjtn000 = new ASTFloat(this, JJTFLOAT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) Float */
        try {
/*@egen*/
	<FLOATING_POINT_LITERAL>/*@bgen(jjtree)*/
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
            jjtreeCloseNodeScope(jjtn000);
          }
        }
/*@egen*/
}

void String() :{/*@bgen(jjtree) String */
  ASTString jjtn000 = new ASTString(this, JJTSTRING);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) String */
        try {
/*@egen*/
	<QUOTED_STRING>/*@bgen(jjtree)*/
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
            jjtreeCloseNodeScope(jjtn000);
          }
        }
/*@egen*/
}