:- module(layout_rules,[layout_rule/4,child_class/4]).
:- use_module(library('pef/pef_base')).
:- use_module(library('pef/pef_api')).
:- use_module(library('org/cs3/pdt/util/pdt_util_map')).

/*
Layout is determined by a set of rules that take the following form:

layout_rule(+Pattern, +Class, +NeedsParenthesis, +Tokens)

Pattern - A pattern against which the term that is processed is matched. 
variable bindings can be used in the token list.)
Class - currently one of toplevel, head, formula, literal or term. It may make sense to allow
        custom classes as well. See below.
Hints - a pdt_map containing hints for the layout rule. Rules can add/modify custom hints 
        that will be visible by subsequently applied rules. This is done by using the key=value token.
		Predefined hints are: 
			- have_pars - is true iff the current term needs to be put into parenthesis.			        
Tokens - a list of tokens produced by this rule. Currently the following set of tokens is interpreted:

 
cma - represents a comma character (',')
tab - represents a tabulator character 
lpr - represents a left/opening parenthesis
rpr - reoresents a right/closing parenthesis 
nl  - reoresents a line delimiter + a whitespace sequence to move the "cariage" to the base position.(see below)
spc - represents a space character
eoc - represents an end-of-clause character ('.')
fun - the layout engine should output the functor name here.
inc	- the layout engine should shift the base marker one tab stop to the right.
arg(MatchedSubterm)
    - the layout engine should process a matched subterm here. 
      (Note: currently this only works with direct children, i.e. arguments. 
      I will generalize this to arbitrary subterms if the need should arise
      )
arg_num(I)       
    - Same as above, but arguments are addressed by their position. Usefull for 
      generic fall-back rules.
<key>=<value> 
	- set or modify a hint that will be visible by subsequently applied rules.
In principle those layout rules should be editable by the end user, but currently the syntax is a bit "awkward". 
I am not entirely sure about the exact requirements for those layout rules, so I will first
try to build a useable set of default rules and hard-wire them first. This should give me a better 
understanding of how flexible the rules need to be.   

Long-term goals:
  - Users should be allowed to define their own classifier rules (probably only interesting for "advanced" users).
    see the "child_class" predicate in layout.pl. Something like this. Note that any information associated with the
    ast can be used by these rules. The separation of classifier rules and the actual layout rules should help us 
    to keep the simple things simple while making the difficult things possible. 
  - Users should be able to specify layout rules  "by example", i.e. they give a textual representation 
    of a prolog term, and a preprocessor creates the actual rule from it. The only additional information
    would be the class of terms for which the rule applies. So rules could look like this:


formula:
(	A
->	B
;	C
).
 
The following information can be drawn from such a representation right away:
- The standard prolog pareser (read_term/2) can be used to obtain the pattern.
- The class to which this rule aplies is "formula", this is explicitly specified.
The following two things would require a special "tokenizer"
- The fact that the term is surrounded by parenthesis tells us that the rule applies to situations
  where that term needs to be put in parenthesis.
- Looking at the representation character by character, the list of tokens generated by a match to this rule
  can be deduced. This is probably the most difficult part, but it should be doable. 
   



For the default layout, i like to adhere to the following rule-o-thumbs. The set is still incomplete.
In particular, I think that certain directives need special treatment (module definitions, etc.).
I also did not spend mucht thought on line wrapping. Or data terms, lists, etc. 

About operators: The layout assumes that the pef-base is in a consistent state, that is, all operator definitions
are where they belong BEFORE the layout is requested. Also note that the layout engine needs to know the toplevel 
to which the term beeing processed belongs. It uses this information to figure out which custom operator definitions 
should be considered during layout. (Note: this is not implemented, but should be easy - I do basically the same 
for the outline already.)  


 - There is always at most one literal per line. For meta-calls like to forall/2 aswell as to user-defined
   meta-predicates: the functor is on a line of its own. Each argument starts on a new line, with indention 
   increased by one tab step. The right parenthesis closing the arguments list is alligned with the functor.
   E.g.:
   forall(
   		literal,
   		(	literal,
   			literal
   		)
   	)
    
 - conjunction (,)/2 is always followed by a line delimiter.  Both arguments are left-aligned.
 - all other infix junctors are the first non-whitespace character in a line and are followed by a tabulator. 
   Both arguments are left-aligned. e.g.

	argument1
;	argument2
   
   In case of non-atomic arguments, that do not need parenthesis, this would leed to something like this:
 
 	foo
 ->	bar
 ;	baz,
    bam
   
 - prefix junctors like negaqtion (\+)/1  are on the same line as their argument starts. Only one space between.
 - formulas in parenthesis should start at the same line as the opening parenthesis, but with indention increased
   by one tab step. Opening and closing parenthesis should be aligned, the closing parenthesis beeing on a 
   line of its own. Leading infix junctors (see above) should be aligned with the parenthesis. 
   Most prominent example:
   (	literal,
   		literal,
   ->	literal,
   		litera,
   		...
   ;	literal,
   		...
   )
   	 
 
*/



/*
Layout structure, nested indents, etc.

There are two tab stops, that the layout engine keeps track of.
the base stop is the horizontal position, to which the "carriage" is returned after a line delimiter.
the indent stop (or simply indent) is the horizontal position at which operands of a conjunction are aligned.

The inc token is interpreted like this: the current indent becomes the base indent, the full indent is base indent 
+ one tab stop.

initialy, both tab stops are at column 0. The toplevel layout rules should include a inc token, effectively
setting indent to the first tab stop while keeping base at the start of the line.
Infix junctors that need parenthesis will also typically include an inc token. 
In general, tokens should be placed such that
- literals start at indent (exception: first literals in a directive and of course head literals)
- opening/closing brackets and infix junctors other than conjunction start at base
*/

node_class(Node,Class):-
    (	pef_property_query([pef=Node,key=builtin_meta_call,value=true])
    ->	Class=formula
    ;	pef_property_query([pef=Node,key=meta_call,value=true])
    ->	Class=formula
    ;	pef_call_query([goal=Node])
    ->	Class=literal
    ;	pef_unresolved_predicate_symbol_query([goal=Node])
    ->	Class=literal
    ;	Class=term
    ).

%child_class(ParentClass,Parent,Child,ChildClass).
child_class(toplevel,Parent,Child,ChildClass):-
	pef_arg_query([parent=Parent,child=Child,num=Num]),
	!,    
    pef_term_query([id=Parent,arity=Arity]),       
    (	Num < Arity
    ->	ChildClass=literal
    ;	node_class(Child,ChildClass)
    ). 
child_class(_,_,Child,ChildClass):-
    node_class(Child,ChildClass).

marked_as_literal(Node):-
    pef_call_query([goal=Node]),!.
marked_as_literal(Node):-
    pef_unresolved_predicate_symbol_query([goal=Node]).


% special treatment for module definitions
layout_rule( (:-module(Name,Exports)), toplevel, _, Tokens):-
    Tokens=[raw(":- module("),inc,nl,
    			arg(Name),cma,nl,
    			orientation=vertical,arg(Exports),dec,nl,
    			raw(").")].


% other toplevel rules
layout_rule( (:-A), toplevel,_,[fun,spc,where=directive,arg(A),eoc]).
layout_rule( (A:-B), toplevel,_,[where=head,arg(A),spc,fun,nl,tab,where=body,arg(B),eoc]).
layout_rule( A , toplevel,Hints,[where=head|Tokens]):-
    pdt_map_put(Hints,where,head,Hints2),
	layout_rule(A,literal,Hints2,Tokens).                     

    
% special treatment for conjunction 
layout_rule((A,B), formula, Hints, Tokens):- 
	(	pdt_map_get(Hints,have_pars,true)
	->	Tokens=[lpr,tab,inc,arg(A),fun,nl,
				    tab,arg(B),nl, 
				rpr
			    ]
	;	Tokens=[	arg(A),fun,nl,
				tab,arg(B)
			   ]
	).                             
            	
% special treatment for module qualifiers.
% (:)/2 is interpreted as a built-in metacall.
% The layout engine should not treate it as a junctor, though.
layout_rule((A:B),formula,Hints,Tokens):-
	(	pdt_map_get(Hints,have_pars,true)
	->	Tokens=[lpr,tab,inc,arg(A),fun,arg(B),nl,rpr]
	;	Tokens=[arg(A),fun,arg(B)]
	).
layout_rule((A:B),literal,Hints,Tokens):-
	(	pdt_map_get(Hints,have_pars,true)
	->	Tokens=[lpr,tab,inc,arg(A),fun,arg(B),nl,rpr]
	;	Tokens=[arg(A),fun,arg(B)]
	).

% special treatement for signatures: we boldly assume that all (/)/2 terms are signatures,
% There should not be spaces between functor and arguments.
layout_rule((A/B),term,Hints,Tokens):-
	(	pdt_map_get(Hints,have_pars,true)
	->	Tokens=[lpr,arg(A),fun,arg(B),rpr]
	;	Tokens=[arg(A),fun,arg(B)]
	).

% special treatment for commata in terms: 
% there should be a space after, but not before the functor. 
layout_rule((A,B),term,Hints,Tokens):-
	(	pdt_map_get(Hints,have_pars,true)
	->	Tokens=[lpr,arg(A),fun,spc,arg(B),rpr]
	;	Tokens=[arg(A),fun,spc,arg(B)]
	).



% rules for other infix ops in both, formulas and terms.
layout_rule((A), Class, Hints, Tokens):-
	nonvar(A),
	functor(A,Name,2),
	current_op(_,Type,Name),
	atom_length(Type,3),
	!,
	(	pdt_map_get(Hints,have_pars,true)
	->	(	Class==formula
		->	Tokens=[lpr,tab,inc,arg_num(1),nl,
	                    fun,tab,arg_num(2),nl,
	                rpr
	               ]
		;	Tokens=[lpr,arg_num(1),spc,fun,spc,arg_num(2),rpr]
		)
	;	(	Class=formula
		->	Tokens=[ 		arg_num(1),nl,
	              	fun,tab,arg_num(2)
	               ]
		;	Tokens=[arg_num(1),spc,fun,spc,arg_num(2)]
		)
	).

% prefix ops (all classes):
layout_rule((A), _, _,[fun,spc,inc,arg_num(1)]):-
	nonvar(A),
	functor(A,Name,1),
	current_op(_,Type,Name),
	memberchk(Type,[fx,fy]).



%fallback for non-op meta calls
layout_rule( A ,formula,_,TokensOut):-
	nonvar(A),  
	functor(A,_,Arity),  
    findall(
    	[nl,tab,arg_num(I)|Delim],
    	(	between(1,Arity,I),
    		(	I<Arity
    		->	Delim=[cma]
    		;	Delim=[]
    		)
    	),
    	ArgTokens0
    ),
    flatten(ArgTokens0,ArgTokens),
    append([fun,lpr,inc|ArgTokens],[nl,rpr],TokensOut).


% lists and pseudo-lists
layout_rule([A|B],_, Hints,Tokens):-
    (	pdt_map_get(Hints,sublist,true)
    ->	Tokens=[cma,spc,sublist=false,arg(A),sublist=true,arg(B)]
    ;	Tokens=[lsb,arg(A),sublist=true,arg(B),sublist=false,rsb]
    ).
layout_rule([],_, Hints,Tokens):-
    (	pdt_map_get(Hints,sublist,true)
    ->	Tokens=[]
    ;	Tokens=[fun]
    ).
layout_rule(Anything,Class, Hints,[mid,sublist=false|Tokens]):-    
	pdt_map_get(Hints,sublist,true),
	pdt_map_put(Hints,sublist,false,Hints2),
	layout_rule(Anything,Class,Hints2,Tokens).
	
	
% variable rule, all classes:
layout_rule(A,_,_,[fun]):-
    var(A).
	

%fallback for almost anything else
layout_rule( A ,_,_,Tokens):-
	nonvar(A),    
    functor(A,_,Arity),
    (	Arity > 0 
    ->	arg_layout([cma,spc,arg_num(Arity)],ArgTokens),
    	append([fun,lpr|ArgTokens],[rpr],Tokens)
    ;	Tokens=[fun]
    ).



arg_layout([cma,spc,arg_num(1)|More],[arg_num(1)|More]).
arg_layout([cma,spc,arg_num(I)|More],EvenMore):-
	J is I - 1,
	arg_layout([cma,spc,arg_num(J),cma,spc,arg_num(I)|More],EvenMore).

