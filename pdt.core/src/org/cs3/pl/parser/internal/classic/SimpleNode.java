/*****************************************************************************
 * This file is part of the Prolog Development Tool (PDT)
 * 
 * Author: Lukas Degener (among others) 
 * E-mail: degenerl@cs.uni-bonn.de
 * WWW: http://roots.iai.uni-bonn.de/research/pdt 
 * Copyright (C): 2004-2006, CS Dept. III, University of Bonn
 * 
 * All rights reserved. This program is  made available under the terms 
 * of the Eclipse Public License v1.0 which accompanies this distribution, 
 * and is available at http://www.eclipse.org/legal/epl-v10.html
 * 
 * In addition, you may at your option use, modify and redistribute any
 * part of this program under the terms of the GNU Lesser General Public
 * License (LGPL), version 2.1 or, at your option, any later version of the
 * same license, as long as
 * 
 * 1) The program part in question does not depend, either directly or
 *   indirectly, on parts of the Eclipse framework and
 *   
 * 2) the program part in question does not include files that contain or
 *   are derived from third-party work and are therefor covered by special
 *   license agreements.
 *   
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software Foundation,
 * Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
 *   
 * ad 1: A program part is said to "depend, either directly or indirectly,
 *   on parts of the Eclipse framework", if it cannot be compiled or cannot
 *   be run without the help or presence of some part of the Eclipse
 *   framework. All java classes in packages containing the "pdt" package
 *   fragment in their name fall into this category.
 *   
 * ad 2: "Third-party code" means any code that was originaly written as
 *   part of a project other than the PDT. Files that contain or are based on
 *   such code contain a notice telling you so, and telling you the
 *   particular conditions under which they may be used, modified and/or
 *   distributed.
 ****************************************************************************/

/* Generated By:JJTree: Do not edit this line. SimpleNode.java */

package org.cs3.pl.parser.internal.classic;

/**
 * @author windeln
 *
 * To change the template for this generated type comment go to
 * Window - Preferences - Java - Code Generation - Code and Comments
 */
public class SimpleNode implements Node {
	protected Node parent;
	public Node[] children;
	protected int id;
	protected PrologParser parser;
	private Token firstToken;
	private Token lastToken;
	private boolean hasMinusPrefix = false;
	private boolean hasPlusPrefix = false;
	
	public SimpleNode(int i) {
		id = i;
	}
	
	public SimpleNode(PrologParser p, int i) {
		this(i);
		parser = p;
	}
	
	public void jjtOpen() {
	}
	
	public void jjtClose() {
	}
	
	public void jjtSetParent(Node n) { parent = n; }
	public Node jjtGetParent() { return parent; }
	
	public void jjtAddChild(Node n, int i) {
		if (children == null) {
			children = new Node[i + 1];
		} else if (i >= children.length) {
			Node c[] = new Node[i + 1];
			System.arraycopy(children, 0, c, 0, children.length);
			children = c;
		}
		children[i] = n;
	}
	
	public Node jjtGetChild(int i) {
		return children[i];
	}
	
	public int jjtGetNumChildren() {
		return (children == null) ? 0 : children.length;
	}
	
	/** Accept the visitor. **/
	public Object jjtAccept(PrologParserVisitor visitor, Object data) {
		return visitor.visit(this, data);
	}
	
	/** Accept the visitor. **/
	public Object childrenAccept(PrologParserVisitor visitor, Object data) {
		if (children != null) {
			for (int i = 0; i < children.length; ++i) {
				children[i].jjtAccept(visitor, data);
			}
		}
		return data;
	}
	
	/* You can override these two methods in subclasses of SimpleNode to
	 customize the way the node appears when the tree is dumped.  If
	 your output uses more than one line you should override
	 toString(String), otherwise overriding toString() is probably all
	 you need to do. */
	
	public String toString() { return PrologParserTreeConstants.jjtNodeName[id]; }
	public String toString(String prefix) { return prefix + toString(); }
	
	/* Override this method if you want to customize how the node dumps
	 out its children. */
	
	public void dump(String prefix) {
		System.out.println(toString(prefix));
		if (children != null) {
			for (int i = 0; i < children.length; ++i) {
				SimpleNode n = (SimpleNode)children[i];
				if (n != null) {
					n.dump(prefix + " ");
				}
			}
		}
	}
	/**
	 * @return Returns the token.
	 */
	public Token getFirstToken() {
			return firstToken;
	}
	public Token getStartToken(){
		return getFirstToken();
	}
	/**
	 * @return Returns the last token that is part of this node.
	 */
	public Token getLastToken() {
			return lastToken;
	}
	
	/**
	 * @return Returns the first token that is NOT part of this node.
	 */	
	 public Token getEndToken(){
		 return getLastToken().next;
	 }
	
	/* (non-Javadoc)
	 * @see org.cs3.pl.parser.Node#setFlag(org.cs3.pl.parser.Token)
	 */
	public void setFlag(Token token) {
		if(token.image.charAt(0) == '-')
			hasMinusPrefix = true;
		else if(token.image.charAt(0) == '+')
			hasPlusPrefix = true;
		
	}
	/**
	 * @return Returns the hasMinusPrefix.
	 */
	public boolean isHasMinusPrefix() {
		return hasMinusPrefix;
	}
	/**
	 * @return Returns the hasPlusPrefix.
	 */
	public boolean isHasPlusPrefix() {
		return hasPlusPrefix;
	}
	
	
	/**
	 * 
	 * Retrieves the comments above this prolog element starting
	 * with the first occurance of <b>predname</b>.
	 * 
	 * @param predname specifies the starting point of the comment.
	 * 		
	 * @see org.cs3.pl.parser.internal.classic.Node#getComment(java.lang.String)
	 */
	
	public String getComment(String predname) {
		Token token = getStartToken().specialToken;
		if(token != null)
		   if(token.image.startsWith("/*"))
			return makeSwiConformString(predname,token.image,token.image.length(),2,2);
		   else if(token.image.startsWith("%")){
		   		String buf = new String();
		   		do {
		   			buf = token.image.substring(1) + buf;
		   			token = token.specialToken;
		   		} while(token != null);
		   		return makeSwiConformString(predname,buf.toString(),buf.length(),1,0);
		   }
		return null;
				
	}

	/**
	 * @param string
	 * @return
	 */
	private String makeSwiConformString(String predname, String str, int len, int removeStart, int removeEnd) {
//		int i = begin;

//		while(isWhileSpace(str.charAt(i)) && i < end) 
//			i++;
		int start;
		if (predname == null)
			start = removeStart;
		else 
			start = str.indexOf(predname);
		if(start > -1)
			return "\""+str.substring(start,len-removeEnd).replaceAll("\"","\\\\\"")+"\"";
		return null;
	}

	/**
	 * @param c
	 * @return
	 */
	private boolean isWhileSpace(char c) {
		switch(c) {
			case '\n':
			case '\r':
			case '\t':
			case ' ':
				return true;
			default:
				return false;
		}
	}

	public void setFirstToken(Token firstToken) {
		this.firstToken = firstToken;
	}

	public void setLastToken(Token lastToken) {
		this.lastToken = lastToken;
	}

	public String getImage(){
		StringBuffer buf = new StringBuffer();		
		for(Token t = getStartToken();t!=getEndToken();t=t.next){
			buf.append(t.image);
		}
		return buf.toString();
	}
}

