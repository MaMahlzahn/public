/*****************************************************************************
 * This file is part of the Prolog Development Tool (PDT)
 * 
 * Author: Lukas Degener (among others) 
 * E-mail: degenerl@cs.uni-bonn.de
 * WWW: http://roots.iai.uni-bonn.de/research/pdt 
 * Copyright (C): 2004-2006, CS Dept. III, University of Bonn
 * 
 * All rights reserved. This program is  made available under the terms 
 * of the Eclipse Public License v1.0 which accompanies this distribution, 
 * and is available at http://www.eclipse.org/legal/epl-v10.html
 * 
 * In addition, you may at your option use, modify and redistribute any
 * part of this program under the terms of the GNU Lesser General Public
 * License (LGPL), version 2.1 or, at your option, any later version of the
 * same license, as long as
 * 
 * 1) The program part in question does not depend, either directly or
 *   indirectly, on parts of the Eclipse framework and
 *   
 * 2) the program part in question does not include files that contain or
 *   are derived from third-party work and are therefor covered by special
 *   license agreements.
 *   
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program; if not, write to the Free Software Foundation,
 * Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
 *   
 * ad 1: A program part is said to "depend, either directly or indirectly,
 *   on parts of the Eclipse framework", if it cannot be compiled or cannot
 *   be run without the help or presence of some part of the Eclipse
 *   framework. All java classes in packages containing the "pdt" package
 *   fragment in their name fall into this category.
 *   
 * ad 2: "Third-party code" means any code that was originaly written as
 *   part of a project other than the PDT. Files that contain or are based on
 *   such code contain a notice telling you so, and telling you the
 *   particular conditions under which they may be used, modified and/or
 *   distributed.
 ****************************************************************************/

/*@bgen(jjtree) Generated By:JJTree: Do not edit this line. prolog.jj */
/*@egen*/options {
  STATIC=false;                                                                                                                     
  DEBUG_PARSER=false;
  DEBUG_LOOKAHEAD=false;
  DEBUG_TOKEN_MANAGER=false;
  OPTIMIZE_TOKEN_MANAGER=true;                         
}

PARSER_BEGIN(PrologParser)
package org.cs3.pl.parser;
import java.util.ArrayList;
import java.util.List;

public class PrologParser/*@bgen(jjtree)*/implements PrologParserTreeConstants/*@egen*/
{/*@bgen(jjtree)*/
  protected JJTPrologParserState jjtree = new JJTPrologParserState();

/*@egen*/
	void jjtreeOpenNodeScope(Node n)
    {
      ((SimpleNode)n).setFirstToken(getToken(1));
    }

    void jjtreeCloseNodeScope(Node n)
    {
      ((SimpleNode)n).setLastToken(getToken(0));
    }
    
    public ASTCompilationUnit getASTRoot(){
		return (ASTCompilationUnit) jjtree.rootNode();
  	}
    
	private List errors = new ArrayList();
	
	public List getErrors() {
		return errors;
	}

	public void error_skipto(int kind) {
	  ParseException e = generateParseException();  // generate the exception object.
	  errors.add(e);
//	  System.out.println(e.toString());  // print the error message
	  Token t;
	  do {
	    t = getNextToken();
	  } while (t.kind != kind && t.kind != EOF);
//	  if(t.kind != EOF)
	//  	getNextToken();
	    // The above loop consumes tokens all the way up to a token of
	    // "kind".  We use a do-while loop rather than a while because the
	    // current token is the one immediately before the erroneous token
	    // (in our case the token immediately before what should have been
	    // "if"/"while".
	}

    public static void main (String [] args) {
        PrologParser parser;
        String filename = null;
        long initTime = 0;
        long parseTime = 0;
        long startTime = 0;
        long stopTime = 0;
        if (args.length == 0)
        {
            System.out.println("Prolog Parser Version 0.1:  Reading from standard input . . .");
            parser = new PrologParser(System.in);
        } else if (args.length == 1)
        {
            filename = args[0];
            System.out.println("Prolog Parser Version 0.1:  Reading from file " + filename + " . . .");
            try
            {
                startTime = System.currentTimeMillis();
                parser = new PrologParser(new java.io.FileInputStream(filename));
                stopTime = System.currentTimeMillis();
                initTime = stopTime - startTime;
            } catch (java.io.FileNotFoundException e)
            {
                System.out.println("Prolog Parser Version 0.1:  File " + filename + " not found.");
                return;
            }
        } else
        {
            System.out.println("Prolog Parser Version 0.1:  Usage is one of:");
            System.out.println("         java PrologParser < inputfile");
            System.out.println("OR");
            System.out.println("         java PrologParser inputfile");
            return;
        }
        try
        {
            startTime = System.currentTimeMillis();
            parser.CompilationUnit();
            stopTime = System.currentTimeMillis();
            parseTime = stopTime - startTime;
            System.out.println("Prolog Parser Version 0.1: ");
            System.out.println("   Prolog program parsed " + filename + " successfully in " + (initTime + parseTime) + " ms.");
            System.out.println("      parser initialization time was " + initTime + " ms.");
            System.out.println("      parser parse time was " + parseTime + " ms.");
        } catch (ParseException e)
        {
            System.out.println(e.getMessage());
            System.out.println("Prolog Parser Version 0.1:  Encountered errors during parse.");
        }
    }

}

PARSER_END(PrologParser)


/* WHITE SPACE */

SKIP :
{
  " "
| "\t"
| "\n"
| "\r"
| "\f"
}

/* COMMENTS */

MORE :
{
//  "%" : IN_SINGLE_LINE_COMMENT
//|
  "/*" : IN_MULTI_LINE_COMMENT
}

/*
<IN_SINGLE_LINE_COMMENT>
SPECIAL_TOKEN :
{
  <SINGLE_LINE_COMMENT: "\n" | "\r" | "\r\n" > : DEFAULT
}*/

SPECIAL_TOKEN : {

    < SINGLE_LINE_COMMENT: "%"(~["\n","\r"])* ("\n"|"\r"|"\r\n")? > }


<IN_MULTI_LINE_COMMENT>
SPECIAL_TOKEN :
{
  <MULTI_LINE_COMMENT: "*/" > : DEFAULT
}

<IN_SINGLE_LINE_COMMENT,IN_MULTI_LINE_COMMENT>
MORE :
{
  < ~[] >
}

/* RESERVED WORDS AND LITERALS */

TOKEN :
{
  < DYNAMIC: "dynamic" >
| < MULTIFILE: "multifile" >
| < INIT: "initialization" >
| < MODULE_TRANSPARENT : "module_transparent" >
| < VOLATILE : "volatile" >
}

/* OPERATORS */

TOKEN :
{
  < ASSIGN: "=" >
| < METAASSIGN: "=.." >
| < GT: ">" >
| < LT: "<" >
| < CUT: "!" >
| < ARROW: "-->" >
| < IF: "->" >
| < SOFTCUT: "*->" >
| < QUERY: "?-" >
| < CLAUSEDEF: ":-" >
| < COLON: ":" >
| < EQ: "==" >
| < EQ2: "=:=" >
| < EQ3: "=\\=" >
| < EQ4: "=@=" >
| < NEQ: "\\=" >
| < NEQ2: "\\==" >
| < IS: "is" >
| < LE: "<=" >
| < LE2: "=<" >
| < GE: ">=" >
| < GE2: "=>" >
| < NE: "!=" >
| < PLUS: "+" >
| < MINUS: "-" >
| < STAR: "*" >
| < NOTPROVABLE: "\\+" >
| < MOD: "mod" >
| < LSHIFT: "<<" >
| < RSIGNEDSHIFT: ">>" >
| < DOLLAR: "$" >
| < SLASH: "/">
| < POINTER: "^">
| < AT: "@">
| < DIVISION: "//">
| < BITAND: "/\\">
| < BITOR: "\\//">
| < BITNOT: "\\/">
| < BITXOR: "xor">
}


/* LITERALS */

TOKEN :
{
//  < ARITY_LITERAL: [<SLASH>] ["1"-"9"] (["0"-"9"])* >
//|
  < DECIMAL_LITERAL: ["0"-"9"] (["0"-"9"])* >
|
  < BIN_LITERAL: ["0"-"9"] "b" ["0"-"1"] (["0"-"1"])* >
|
  < OCT_LITERAL: ["0"-"9"] "o" ["0"-"7"] (["0"-"7"])* >
|
  < HEX_LITERAL: ["0"-"9"] "x" ["0"-"9","A"-"F","a"-"f"] (["0"-"9","A"-"F","a"-"f"])* >
|
  < FLOATING_POINT_LITERAL:
        (["0"-"9"])+ "." (["0"-"9"])+ (<EXPONENT>)? /*(["f","F","d","D"])?*/
//      | "." (["0"-"9"])+ (<EXPONENT>)? /*(["f","F","d","D"])?*/
      | (["0"-"9"])+ <EXPONENT> /*(["f","F","d","D"])?*/
      | (["0"-"9"])+ (<EXPONENT>)? /*["f","F","d","D"]*/
  >
|
  < #EXPONENT: ["e","E"] (["+","-"])? (["0"-"9"])+ >
|
  < CHARACTER_ATOM:
      "'"
      (   (~["\'","\\","\n","\r"])
        | ("\\"
            ( ["n","t","b","r","f","\\","'","\""]
            )
          )
        | ("''")
      )*
      "'"
  >
|
  < STRING_LITERAL:
      "\""
      (   (~["\"","\\"]) /*,"\n","\r"*/
        | ("\\"
            ( ["n","t","b","r","f","\\","'","\""]
            | ["0"-"7"] ( ["0"-"7"] )?
            | ["0"-"3"] ["0"-"7"] ["0"-"7"]
            )
          )
        | ("\"\"")
      )*
      "\""
  >
  |
    < ZERO_APO_REST: "0'" ~["'"] >
  
}

/* IDENTIFIERS */

TOKEN :
{
  < VARIABLE: (<UNDERLINE> | <UPPERLETTER>) (<DIGIT>|<UPPERLETTER>|<LOWERLETTER>|<UNDERLINE>)* >
| 
  < IDENTIFIER: (<LOWERLETTER>|<DOLLAR>)(<DIGIT>|<UPPERLETTER>|<LOWERLETTER>|<VARIABLE>)* >
|
  < #UNDERLINE:
      [
       "_"
      ]
  >
|

  < #UPPERLETTER:
      [
       "A"-"Z"
      ]
  >
|
  < #DIGIT:
      [
       "0"-"9"
      ]
  >
|
  < #LOWERLETTER:
      [
       "a"-"z"
      ]
  >
}


/* SEPARATORS */

TOKEN :
{
  < LPAREN: "(" >
| < RPAREN: ")" >
| < LBRACE: "{" >
| < RBRACE: "}" >
| < LBRACKET: "[" >
| < RBRACKET: "]" >
| < SEMICOLON: ";" >
| < COMMA: "," >
| < DOT: "." >
| < LISTSEP: "|" >
}

/*****************************************
 * THE JAVA LANGUAGE GRAMMAR STARTS HERE *
 *****************************************/

/*
 * Program structuring syntax follows.
 */

void CompilationUnit() :
{/*@bgen(jjtree) CompilationUnit */
  ASTCompilationUnit jjtn000 = new ASTCompilationUnit(this, JJTCOMPILATIONUNIT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) CompilationUnit */
   try {
/*@egen*/
   try{
	(Member())*

  <EOF>
	   }
	     catch (ParseException e) {
	    error_skipto(DOT);
	  }/*@bgen(jjtree)*/
   } catch (Throwable jjte000) {
     if (jjtc000) {
       jjtree.clearNodeScope(jjtn000);
       jjtc000 = false;
     } else {
       jjtree.popNode();
     }
     if (jjte000 instanceof RuntimeException) {
       throw (RuntimeException)jjte000;
     }
     if (jjte000 instanceof ParseException) {
       throw (ParseException)jjte000;
     }
     throw (Error)jjte000;
   } finally {
     if (jjtc000) {
       jjtree.closeNodeScope(jjtn000, true);
       jjtreeCloseNodeScope(jjtn000);
     }
   }
/*@egen*/
	  
}

void Member()      :
{}
{
	try{
	  ( 
	    LOOKAHEAD(2)
	    NamedCall() 
	  |
	    Call()
	  | 
	    Clause()
	   )
	   }
	     catch (ParseException e) {
	    error_skipto(DOT);
	  }
}

void Functor() :
{/*@bgen(jjtree) Functor */
     ASTFunctor jjtn000 = new ASTFunctor(this, JJTFUNCTOR);
     boolean jjtc000 = true;
     jjtree.openNodeScope(jjtn000);
     jjtreeOpenNodeScope(jjtn000);
/*@egen*/    Token token;
}
{/*@bgen(jjtree) Functor */
    try {
/*@egen*/
    ( LOOKAHEAD(2) token=<IDENTIFIER> 
      {jjtn000.setModuleName(token.image.toString());} <COLON> )?
    (
    token=<IDENTIFIER>/*@bgen(jjtree)*/
    {
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
      jjtreeCloseNodeScope(jjtn000);
    }
/*@egen*/ 
    {jjtn000.setName(token.image.toString()); }
    | token=<DYNAMIC>/*@bgen(jjtree)*/
    {
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
      jjtreeCloseNodeScope(jjtn000);
    }
/*@egen*/ 
    {jjtn000.setName(token.image.toString()); }
    | token=<MULTIFILE>/*@bgen(jjtree)*/
    {
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
      jjtreeCloseNodeScope(jjtn000);
    }
/*@egen*/ 
    {jjtn000.setName(token.image.toString()); }
    | token=<MODULE_TRANSPARENT>/*@bgen(jjtree)*/
    {
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
      jjtreeCloseNodeScope(jjtn000);
    }
/*@egen*/ 
    {jjtn000.setName(token.image.toString()); }
    | token=<VOLATILE>/*@bgen(jjtree)*/
    {
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
      jjtreeCloseNodeScope(jjtn000);
    }
/*@egen*/ 
    {jjtn000.setName(token.image.toString()); }
//    | token=<INIT> 
//    {jjtThis.setName(token.image.toString()); }
    | token=<POINTER>/*@bgen(jjtree)*/
    {
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
      jjtreeCloseNodeScope(jjtn000);
    }
/*@egen*/ 
    {jjtn000.setName(token.image.toString()); }
    | token=<AT>/*@bgen(jjtree)*/
    {
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
      jjtreeCloseNodeScope(jjtn000);
    }
/*@egen*/ 
    {jjtn000.setName(token.image.toString()); }

//    | token=<IS> 
//    {jjtThis.setName(token.image.toString()); }
//    | token=<MOD> 
//    {jjtThis.setName(token.image.toString()); }
    | token=<CHARACTER_ATOM>/*@bgen(jjtree)*/
    {
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
      jjtreeCloseNodeScope(jjtn000);
    }
/*@egen*/
    {jjtn000.setName(token.image.toString()); }
	)/*@bgen(jjtree)*/
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
        jjtreeCloseNodeScope(jjtn000);
      }
    }
/*@egen*/
}


/* ************* ********** ************* */
/* *************  to delete ************* */
/* ************* ********** ************* */

void FunctorVariableModule() :
{/*@bgen(jjtree) FunctorVariableModule */
     ASTFunctorVariableModule jjtn000 = new ASTFunctorVariableModule(this, JJTFUNCTORVARIABLEMODULE);
     boolean jjtc000 = true;
     jjtree.openNodeScope(jjtn000);
     jjtreeOpenNodeScope(jjtn000);
/*@egen*/    Token token;}
{/*@bgen(jjtree) FunctorVariableModule */
    try {
/*@egen*/
    ( LOOKAHEAD(3) Variable() <COLON> ) ?
    (
    token=<IDENTIFIER>/*@bgen(jjtree)*/
    {
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
      jjtreeCloseNodeScope(jjtn000);
    }
/*@egen*/ 
    {jjtn000.setName(token.image.toString()); }
    | token=<DYNAMIC>/*@bgen(jjtree)*/
    {
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
      jjtreeCloseNodeScope(jjtn000);
    }
/*@egen*/ 
    {jjtn000.setName(token.image.toString()); }
    | token=<MULTIFILE>/*@bgen(jjtree)*/
    {
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
      jjtreeCloseNodeScope(jjtn000);
    }
/*@egen*/ 
    {jjtn000.setName(token.image.toString()); }
    | token=<MODULE_TRANSPARENT>/*@bgen(jjtree)*/
    {
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
      jjtreeCloseNodeScope(jjtn000);
    }
/*@egen*/ 
    {jjtn000.setName(token.image.toString()); }
    | token=<VOLATILE>/*@bgen(jjtree)*/
    {
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
      jjtreeCloseNodeScope(jjtn000);
    }
/*@egen*/ 
    {jjtn000.setName(token.image.toString()); }
//    | token=<INIT> 
//    {jjtThis.setName(token.image.toString()); }
    | token=<IS>/*@bgen(jjtree)*/
    {
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
      jjtreeCloseNodeScope(jjtn000);
    }
/*@egen*/ 
    {jjtn000.setName(token.image.toString()); }
    | token=<MOD>/*@bgen(jjtree)*/
    {
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
      jjtreeCloseNodeScope(jjtn000);
    }
/*@egen*/ 
    {jjtn000.setName(token.image.toString()); }
    | token=<CHARACTER_ATOM>/*@bgen(jjtree)*/
    {
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
      jjtreeCloseNodeScope(jjtn000);
    }
/*@egen*/
    {jjtn000.setName(token.image.toString()); }
	)/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
        jjtreeCloseNodeScope(jjtn000);
      }
    }
/*@egen*/
}

void Variable() :
{/*@bgen(jjtree) Variable */
    ASTVariable jjtn000 = new ASTVariable(this, JJTVARIABLE);
    boolean jjtc000 = true;
    jjtree.openNodeScope(jjtn000);
    jjtreeOpenNodeScope(jjtn000);
/*@egen*/
    Token token;
}
{/*@bgen(jjtree) Variable */
    try {
/*@egen*/
    token=<VARIABLE>/*@bgen(jjtree)*/
    {
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
      jjtreeCloseNodeScope(jjtn000);
    }
/*@egen*/
    {
       jjtn000.setName(token.image.toString());
       
    }/*@bgen(jjtree)*/
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
        jjtreeCloseNodeScope(jjtn000);
      }
    }
/*@egen*/
}

void Identifier() :
{/*@bgen(jjtree) Identifier */
    ASTIdentifier jjtn000 = new ASTIdentifier(this, JJTIDENTIFIER);
    boolean jjtc000 = true;
    jjtree.openNodeScope(jjtn000);
    jjtreeOpenNodeScope(jjtn000);
/*@egen*/
    Token token;
}
{/*@bgen(jjtree) Identifier */
    try {
/*@egen*/
    (
//    token=<POINTER> 
//    {jjtThis.setName(token.image.toString()); }
//    token=<AT> 
//    {jjtThis.setName(token.image.toString()); }
    token=<IDENTIFIER>/*@bgen(jjtree)*/
    {
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
      jjtreeCloseNodeScope(jjtn000);
    }
/*@egen*/
    {jjtn000.setName(token.image.toString()); }
    | token=<DYNAMIC>/*@bgen(jjtree)*/
    {
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
      jjtreeCloseNodeScope(jjtn000);
    }
/*@egen*/ 
    {jjtn000.setName(token.image.toString()); }
    | token=<MULTIFILE>/*@bgen(jjtree)*/
    {
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
      jjtreeCloseNodeScope(jjtn000);
    }
/*@egen*/ 
    {jjtn000.setName(token.image.toString()); }
    | token=<MODULE_TRANSPARENT>/*@bgen(jjtree)*/
    {
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
      jjtreeCloseNodeScope(jjtn000);
    }
/*@egen*/ 
    {jjtn000.setName(token.image.toString()); }
    | token=<VOLATILE>/*@bgen(jjtree)*/
    {
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
      jjtreeCloseNodeScope(jjtn000);
    }
/*@egen*/ 
    {jjtn000.setName(token.image.toString()); }
    
//    | token=<IS> 
//    {jjtThis.setName(token.image.toString()); }
//    | token=<MOD> 
//    {jjtThis.setName(token.image.toString()); }
    | token=<CHARACTER_ATOM>/*@bgen(jjtree)*/
    {
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
      jjtreeCloseNodeScope(jjtn000);
    }
/*@egen*/ 
    {jjtn000.setName(token.image.toString()); }

	)/*@bgen(jjtree)*/
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
        jjtreeCloseNodeScope(jjtn000);
      }
    }
/*@egen*/

}


void NamedCall() :
{/*@bgen(jjtree) NamedCall */
 ASTNamedCall jjtn000 = new ASTNamedCall(this, JJTNAMEDCALL);
 boolean jjtc000 = true;
 jjtree.openNodeScope(jjtn000);
 jjtreeOpenNodeScope(jjtn000);
/*@egen*/Token token;}
{/*@bgen(jjtree) NamedCall */
  try {
/*@egen*/
  (token=<QUERY>|token=<CLAUSEDEF>) 
  (token=<DYNAMIC>|token=<MULTIFILE>|token=<MODULE_TRANSPARENT>|token=<VOLATILE>){jjtn000.setKind(token.kind);} PredicateSignature() (<COMMA> PredicateSignature())* 
  token=<DOT>/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
      jjtreeCloseNodeScope(jjtn000);
    }
  }
/*@egen*/ 
}


void Call() :
{/*@bgen(jjtree) Call */
 ASTCall jjtn000 = new ASTCall(this, JJTCALL);
 boolean jjtc000 = true;
 jjtree.openNodeScope(jjtn000);
 jjtreeOpenNodeScope(jjtn000);
/*@egen*/Token token;}
{/*@bgen(jjtree) Call */
  try {
/*@egen*/
  (token=<QUERY>|token=<CLAUSEDEF>)  (<INIT> {jjtn000.setInitialization(true);} )? 
  Body() {jjtn000.setBody( (ASTBody) jjtree.peekNode() );}
  token=<DOT>/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
      jjtreeCloseNodeScope(jjtn000);
    }
  }
/*@egen*/ 
}


void PredicateSignature() :
{/*@bgen(jjtree) PredicateSignature */
 ASTPredicateSignature jjtn000 = new ASTPredicateSignature(this, JJTPREDICATESIGNATURE);
 boolean jjtc000 = true;
 jjtree.openNodeScope(jjtn000);
 jjtreeOpenNodeScope(jjtn000);
/*@egen*/Token token;}
{/*@bgen(jjtree) PredicateSignature */
    try {
/*@egen*/
    ( <LPAREN>(Functor()|BinaryOp()) <RPAREN>| Functor())<SLASH>token=<DECIMAL_LITERAL>/*@bgen(jjtree)*/
    {
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
      jjtreeCloseNodeScope(jjtn000);
    }
/*@egen*/
    {jjtn000.setArity(token.image.toString());}/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
        jjtreeCloseNodeScope(jjtn000);
      }
    }
/*@egen*/
}

void Clause() :
{/*@bgen(jjtree) Clause */
 ASTClause jjtn000 = new ASTClause(this, JJTCLAUSE);
 boolean jjtc000 = true;
 jjtree.openNodeScope(jjtn000);
 jjtreeOpenNodeScope(jjtn000);
/*@egen*/Token token;}
{/*@bgen(jjtree) Clause */
        try {
/*@egen*/
	(LOOKAHEAD(2) token=<IDENTIFIER>  <COLON> {jjtn000.setModule(token.image.toString());})?
	(
	 <LPAREN> 	
	   Head() {jjtn000.setHead( (ASTHead) jjtree.peekNode() );}
      (	
        (<ARROW>| <CLAUSEDEF>) 
      	Body() {jjtn000.setBody( (ASTBody) jjtree.peekNode() );}
      )?
      <RPAREN> 
	 | 
	  Head() {jjtn000.setHead( (ASTHead) jjtree.peekNode() );}
      (	
        (<ARROW>| <CLAUSEDEF>) 
      	Body() {jjtn000.setBody( (ASTBody) jjtree.peekNode() );}
      )?
	)
	  token=<DOT>/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
            jjtreeCloseNodeScope(jjtn000);
          }
        }
/*@egen*/ 
}

void Head() :
{/*@bgen(jjtree) Head */
  ASTHead jjtn000 = new ASTHead(this, JJTHEAD);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) Head */
        try {
/*@egen*/
	Identifier() {jjtn000.setName(((ASTIdentifier)jjtree.peekNode()).getName());}
	(
	  PredicateArgs() {jjtn000.setArguments( (ASTPredicateArgs) jjtree.peekNode() );}
	)?/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
            jjtreeCloseNodeScope(jjtn000);
          }
        }
/*@egen*/
}

void PredicateArgs() :
{/*@bgen(jjtree) PredicateArgs */
  ASTPredicateArgs jjtn000 = new ASTPredicateArgs(this, JJTPREDICATEARGS);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) PredicateArgs */
    try {
/*@egen*/
    <LPAREN> BodyElement() (<COMMA> BodyElement())* <RPAREN>/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
        jjtreeCloseNodeScope(jjtn000);
      }
    }
/*@egen*/
}


void Term()       :
{}
{
    LOOKAHEAD(4) Compound() /*LOOKAHEAD(3) DividedAtom() |*/ 
    | Cut() 
    | Parenthesis() 
    | Identifier()
    | LOOKAHEAD(1) IntAtom()
    | FloatAtom()
    | StringAtom()
    | BinaryOp()
    | RestTokens()
    | Variable() 
    | List()
    | Braces()
}

void TermWithoutOp()       :
{}
{
    LOOKAHEAD(4) Compound() /*LOOKAHEAD(3) DividedAtom() |*/ 
    | Cut() 
    | Parenthesis() 
    | Identifier()
    | LOOKAHEAD(1) IntAtom()
    | FloatAtom()
    | StringAtom()
    | RestTokens()
    | Variable() 
    | List()
    | Braces()
}

void Compound() :
{/*@bgen(jjtree) Compound */
 ASTCompound jjtn000 = new ASTCompound(this, JJTCOMPOUND);
 boolean jjtc000 = true;
 jjtree.openNodeScope(jjtn000);
 jjtreeOpenNodeScope(jjtn000);
/*@egen*/ASTSequence sequence;}
{/*@bgen(jjtree) Compound */
        try {
/*@egen*/
	(// TODO: what does the pointer mean?
		Atom() (<POINTER>)? sequence=Sequence()/*@bgen(jjtree)*/
                                                        {
                                                          jjtree.closeNodeScope(jjtn000, true);
                                                          jjtc000 = false;
                                                          jjtreeCloseNodeScope(jjtn000);
                                                        }
/*@egen*/ {jjtn000.setArgs( sequence );}
	| 
		Variable() <POINTER> sequence=Sequence()/*@bgen(jjtree)*/
                                                                {
                                                                  jjtree.closeNodeScope(jjtn000, true);
                                                                  jjtc000 = false;
                                                                  jjtreeCloseNodeScope(jjtn000);
                                                                }
/*@egen*/	{jjtn000.setArgs( sequence );}
	)/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
            jjtreeCloseNodeScope(jjtn000);
          }
        }
/*@egen*/
}	

void Cut() :
{/*@bgen(jjtree) Cut */
 ASTCut jjtn000 = new ASTCut(this, JJTCUT);
 boolean jjtc000 = true;
 jjtree.openNodeScope(jjtn000);
 jjtreeOpenNodeScope(jjtn000);
/*@egen*/Token token;}
{/*@bgen(jjtree) Cut */
        try {
/*@egen*/
	token=<CUT>/*@bgen(jjtree)*/
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
            jjtreeCloseNodeScope(jjtn000);
          }
        }
/*@egen*/ 
}

/*
void DividedAtom():
{}
{
    ((LOOKAHEAD(3) SimpleAtom() | Variable())) (BinaryOp() (SimpleAtom() | Variable()))+
}
*/
ASTSequence Sequence() :
{/*@bgen(jjtree) Sequence */
 ASTSequence jjtn000 = new ASTSequence(this, JJTSEQUENCE);
 boolean jjtc000 = true;
 jjtree.openNodeScope(jjtn000);
 jjtreeOpenNodeScope(jjtn000);
/*@egen*/Token token;}
{/*@bgen(jjtree) Sequence */
   try {
/*@egen*/
   token=<LPAREN>
   BodyElement() ( <COMMA> BodyElement())*  <RPAREN>/*@bgen(jjtree)*/
   {
     jjtree.closeNodeScope(jjtn000, true);
     jjtc000 = false;
     jjtreeCloseNodeScope(jjtn000);
   }
/*@egen*/
   {return jjtn000;}/*@bgen(jjtree)*/
   } catch (Throwable jjte000) {
     if (jjtc000) {
       jjtree.clearNodeScope(jjtn000);
       jjtc000 = false;
     } else {
       jjtree.popNode();
     }
     if (jjte000 instanceof RuntimeException) {
       throw (RuntimeException)jjte000;
     }
     if (jjte000 instanceof ParseException) {
       throw (ParseException)jjte000;
     }
     throw (Error)jjte000;
   } finally {
     if (jjtc000) {
       jjtree.closeNodeScope(jjtn000, true);
       jjtreeCloseNodeScope(jjtn000);
     }
   }
/*@egen*/
}

void List() : 
{/*@bgen(jjtree) List */
  ASTList jjtn000 = new ASTList(this, JJTLIST);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
/*@egen*/ Token token; }
{/*@bgen(jjtree) List */
    try {
/*@egen*/
    LOOKAHEAD(2) token=<LBRACKET>  <RBRACKET> | token=<LBRACKET>  BodyElement() (<COMMA> BodyElement())* (<LISTSEP> (Variable() | List()))* <RBRACKET>/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
        jjtreeCloseNodeScope(jjtn000);
      }
    }
/*@egen*/
}

void Braces() : 
{/*@bgen(jjtree) Braces */
     ASTBraces jjtn000 = new ASTBraces(this, JJTBRACES);
     boolean jjtc000 = true;
     jjtree.openNodeScope(jjtn000);
     jjtreeOpenNodeScope(jjtn000);
/*@egen*/    Token token; }
{/*@bgen(jjtree) Braces */
   try {
/*@egen*/
   token=<LBRACE>  BodyElement() ((<COMMA>|<SEMICOLON>)BodyElement())* <RBRACE>/*@bgen(jjtree)*/
   } catch (Throwable jjte000) {
     if (jjtc000) {
       jjtree.clearNodeScope(jjtn000);
       jjtc000 = false;
     } else {
       jjtree.popNode();
     }
     if (jjte000 instanceof RuntimeException) {
       throw (RuntimeException)jjte000;
     }
     if (jjte000 instanceof ParseException) {
       throw (ParseException)jjte000;
     }
     throw (Error)jjte000;
   } finally {
     if (jjtc000) {
       jjtree.closeNodeScope(jjtn000, true);
       jjtreeCloseNodeScope(jjtn000);
     }
   }
/*@egen*/
}

void Parenthesis() :
{/*@bgen(jjtree) Parenthesis */
  ASTParenthesis jjtn000 = new ASTParenthesis(this, JJTPARENTHESIS);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
/*@egen*/ Token token; }
{/*@bgen(jjtree) Parenthesis */
   try {
/*@egen*/
   token=<LPAREN>  BodyElement() ((<COMMA>|<SEMICOLON>)BodyElement())* <RPAREN>/*@bgen(jjtree)*/
   } catch (Throwable jjte000) {
     if (jjtc000) {
       jjtree.clearNodeScope(jjtn000);
       jjtc000 = false;
     } else {
       jjtree.popNode();
     }
     if (jjte000 instanceof RuntimeException) {
       throw (RuntimeException)jjte000;
     }
     if (jjte000 instanceof ParseException) {
       throw (ParseException)jjte000;
     }
     throw (Error)jjte000;
   } finally {
     if (jjtc000) {
       jjtree.closeNodeScope(jjtn000, true);
       jjtreeCloseNodeScope(jjtn000);
     }
   }
/*@egen*/
}

void Atom()       :
{ Token token; }
{
    ( LOOKAHEAD(2) Functor() 
//    | LOOKAHEAD(2) FunctorVariableModule()
    | LOOKAHEAD(1) IntAtom()
    | FloatAtom()
    | StringAtom()
    | BinaryOp()
    | RestTokens()
    )
}

/*
void SimpleAtom() #void :
{ Token token; }
{
    ( 
      Identifier()
    | LOOKAHEAD(1) IntAtom()
    | FloatAtom()
    )
}
*/


void RestTokens() :
{/*@bgen(jjtree) RestTokens */
  ASTRestTokens jjtn000 = new ASTRestTokens(this, JJTRESTTOKENS);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) RestTokens */
   try {
/*@egen*/
   (  
//      token=<SEMICOLON>
//    | token=<COMMA>
     token=<CLAUSEDEF>
    | token=<DOLLAR>
    | token=<ZERO_APO_REST>
   )/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
    jjtreeCloseNodeScope(jjtn000);
  }
/*@egen*/
  { jjtn000.setName(token.image.toString()); }/*@bgen(jjtree)*/
   } finally {
     if (jjtc000) {
       jjtree.closeNodeScope(jjtn000, true);
       jjtreeCloseNodeScope(jjtn000);
     }
   }
/*@egen*/  
}



void IntAtom() :
{/*@bgen(jjtree) IntAtom */
  ASTIntAtom jjtn000 = new ASTIntAtom(this, JJTINTATOM);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
/*@egen*/ Token token; }
{/*@bgen(jjtree) IntAtom */
    try {
/*@egen*/
    (<MINUS> (token=<DECIMAL_LITERAL> | token=<BIN_LITERAL>  | token=<OCT_LITERAL>  | token=<HEX_LITERAL> )/*@bgen(jjtree)*/
      {
        jjtree.closeNodeScope(jjtn000, true);
        jjtc000 = false;
        jjtreeCloseNodeScope(jjtn000);
      }
/*@egen*/
      {jjtn000.setName("-"+token.image.toString()); }  
    | (token=<DECIMAL_LITERAL> | token=<BIN_LITERAL>  | token=<OCT_LITERAL>  | token=<HEX_LITERAL> )/*@bgen(jjtree)*/
      {
        jjtree.closeNodeScope(jjtn000, true);
        jjtc000 = false;
        jjtreeCloseNodeScope(jjtn000);
      }
/*@egen*/
      { jjtn000.setName(token.image.toString()); }   
    )/*@bgen(jjtree)*/
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
        jjtreeCloseNodeScope(jjtn000);
      }
    }
/*@egen*/
}

void FloatAtom() :
{/*@bgen(jjtree) FloatAtom */
  ASTFloatAtom jjtn000 = new ASTFloatAtom(this, JJTFLOATATOM);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
/*@egen*/ Token token; }
{/*@bgen(jjtree) FloatAtom */
    try {
/*@egen*/
    token=<FLOATING_POINT_LITERAL>/*@bgen(jjtree)*/
    {
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
      jjtreeCloseNodeScope(jjtn000);
    }
/*@egen*/ 
    { jjtn000.setName(token.image.toString()); }/*@bgen(jjtree)*/
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
        jjtreeCloseNodeScope(jjtn000);
      }
    }
/*@egen*/
}


void StringAtom() :
{/*@bgen(jjtree) StringAtom */
  ASTStringAtom jjtn000 = new ASTStringAtom(this, JJTSTRINGATOM);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
/*@egen*/ Token token; }
{/*@bgen(jjtree) StringAtom */
    try {
/*@egen*/
    token=<STRING_LITERAL>/*@bgen(jjtree)*/
    {
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
      jjtreeCloseNodeScope(jjtn000);
    }
/*@egen*/
    { jjtn000.setName(token.image.toString()); }/*@bgen(jjtree)*/
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
        jjtreeCloseNodeScope(jjtn000);
      }
    }
/*@egen*/
}

void CharAtom() :
{/*@bgen(jjtree) CharAtom */
  ASTCharAtom jjtn000 = new ASTCharAtom(this, JJTCHARATOM);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
/*@egen*/ Token token; }
{/*@bgen(jjtree) CharAtom */
    try {
/*@egen*/
    token=<CHARACTER_ATOM>/*@bgen(jjtree)*/
    {
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
      jjtreeCloseNodeScope(jjtn000);
    }
/*@egen*/
    { jjtn000.setName(token.image.toString()); }/*@bgen(jjtree)*/
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
        jjtreeCloseNodeScope(jjtn000);
      }
    }
/*@egen*/
}

void Body() :
{/*@bgen(jjtree) Body */
 ASTBody jjtn000 = new ASTBody(this, JJTBODY);
 boolean jjtc000 = true;
 jjtree.openNodeScope(jjtn000);
 jjtreeOpenNodeScope(jjtn000);
/*@egen*/Token token;}
{/*@bgen(jjtree) Body */
    try {
/*@egen*/
    BodyElement() ( Separator() BodyElement())*/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
        jjtreeCloseNodeScope(jjtn000);
      }
    }
/*@egen*/ 
}

void Separator() :
{/*@bgen(jjtree) Separator */
 ASTSeparator jjtn000 = new ASTSeparator(this, JJTSEPARATOR);
 boolean jjtc000 = true;
 jjtree.openNodeScope(jjtn000);
 jjtreeOpenNodeScope(jjtn000);
/*@egen*/Token token;}
{/*@bgen(jjtree) Separator */
        try {
/*@egen*/
 	(token=<COMMA>|token=<SEMICOLON>)/*@bgen(jjtree)*/
        {
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
          jjtreeCloseNodeScope(jjtn000);
        }
/*@egen*/ 
	{jjtn000.setName(token.image.toString()); }/*@bgen(jjtree)*/
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
            jjtreeCloseNodeScope(jjtn000);
          }
        }
/*@egen*/
}
void BodyElement()       :
{Token token;}
{
    ( <NOTPROVABLE> )* 
    (
    	LOOKAHEAD(2)(
	    	(token=<MINUS> | token=<PLUS>) 
	    	(TermWithoutOp()|{}) 
	    	{jjtree.peekNode().setFlag(token);} 
	    ) 
	    |Term()
	 ) // TODO: double occurance of plus or minus  is allowed!
     (
     	BinaryOp() 
     	( <NOTPROVABLE> )* 
	     Term()
     )* // TODO: priorities and not provables!
     
}



void BinaryOp() :
{/*@bgen(jjtree) BinaryOp */
 ASTBinaryOp jjtn000 = new ASTBinaryOp(this, JJTBINARYOP);
 boolean jjtc000 = true;
 jjtree.openNodeScope(jjtn000);
 jjtreeOpenNodeScope(jjtn000);
/*@egen*/Token token;}
{/*@bgen(jjtree) BinaryOp */
try {
/*@egen*/
( 
  token=<ARROW>
| token=<ASSIGN>
| token=<METAASSIGN>
| token=<GT>
| token=<LT>
//| token=<QUERY>
| token=<EQ>
| token=<EQ2>
| token=<EQ3>
| token=<EQ4>
| token=<NEQ>
| token=<NEQ2>
| token=<IS>
| token=<LE>
| token=<GE>
| token=<LE2>
| token=<GE2>
| token=<COLON>
| token=<NE>
| token=<PLUS>
| token=<MINUS>
| token=<STAR>
| token=<LSHIFT>
| token=<RSIGNEDSHIFT>
| token=<IF>
| token=<MOD>
| token=<SOFTCUT>
| token=<SLASH>
| token=<BITAND>
| token=<DIVISION>
| token=<BITOR>
| token=<BITNOT>
| token=<BITXOR>
//  { if(!(token.image.equals("mod") || token.image.equals("is"))) {jj_consume_token(-1); throw new ParseException();}}
)/*@bgen(jjtree)*/
{
  jjtree.closeNodeScope(jjtn000, true);
  jjtc000 = false;
  jjtreeCloseNodeScope(jjtn000);
}
/*@egen*/


{}/*@bgen(jjtree)*/
} finally {
  if (jjtc000) {
    jjtree.closeNodeScope(jjtn000, true);
    jjtreeCloseNodeScope(jjtn000);
  }
}
/*@egen*/
}

