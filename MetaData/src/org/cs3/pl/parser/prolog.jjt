options {
  STATIC=false;
  NODE_USES_PARSER=true;
  NODE_PACKAGE="org.cs3.pl.parser";
  NODE_PREFIX="AST";
  VISITOR=true;
  MULTI=true;
  DEBUG_PARSER=false;
  DEBUG_LOOKAHEAD=false;
  DEBUG_TOKEN_MANAGER=false;
  OPTIMIZE_TOKEN_MANAGER=true;
  NODE_SCOPE_HOOK=true;
}

PARSER_BEGIN(PrologParser)
package org.cs3.pl.parser;
import java.util.ArrayList;
import java.util.List;

public class PrologParser
{
	void jjtreeOpenNodeScope(Node n)
    {
      ((SimpleNode)n).setFirstToken(getToken(1));
    }

    void jjtreeCloseNodeScope(Node n)
    {
      ((SimpleNode)n).setLastToken(getToken(0));
    }
    
    public ASTCompilationUnit getASTRoot(){
		return (ASTCompilationUnit) jjtree.rootNode();
  	}
    
	private List errors = new ArrayList();
	
	public List getErrors() {
		return errors;
	}

	public void error_skipto(int kind) {
	  ParseException e = generateParseException();  // generate the exception object.
	  errors.add(e);
//	  System.out.println(e.toString());  // print the error message
	  Token t;
	  do {
	    t = getNextToken();
	  } while (t.kind != kind && t.kind != EOF);
//	  if(t.kind != EOF)
	//  	getNextToken();
	    // The above loop consumes tokens all the way up to a token of
	    // "kind".  We use a do-while loop rather than a while because the
	    // current token is the one immediately before the erroneous token
	    // (in our case the token immediately before what should have been
	    // "if"/"while".
	}

    public static void main (String [] args) {
        PrologParser parser;
        String filename = null;
        long initTime = 0;
        long parseTime = 0;
        long startTime = 0;
        long stopTime = 0;
        if (args.length == 0)
        {
            System.out.println("Prolog Parser Version 0.1:  Reading from standard input . . .");
            parser = new PrologParser(System.in);
        } else if (args.length == 1)
        {
            filename = args[0];
            System.out.println("Prolog Parser Version 0.1:  Reading from file " + filename + " . . .");
            try
            {
                startTime = System.currentTimeMillis();
                parser = new PrologParser(new java.io.FileInputStream(filename));
                stopTime = System.currentTimeMillis();
                initTime = stopTime - startTime;
            } catch (java.io.FileNotFoundException e)
            {
                System.out.println("Prolog Parser Version 0.1:  File " + filename + " not found.");
                return;
            }
        } else
        {
            System.out.println("Prolog Parser Version 0.1:  Usage is one of:");
            System.out.println("         java PrologParser < inputfile");
            System.out.println("OR");
            System.out.println("         java PrologParser inputfile");
            return;
        }
        try
        {
            startTime = System.currentTimeMillis();
            parser.CompilationUnit();
            stopTime = System.currentTimeMillis();
            parseTime = stopTime - startTime;
            System.out.println("Prolog Parser Version 0.1: ");
            System.out.println("   Prolog program parsed " + filename + " successfully in " + (initTime + parseTime) + " ms.");
            System.out.println("      parser initialization time was " + initTime + " ms.");
            System.out.println("      parser parse time was " + parseTime + " ms.");
        } catch (ParseException e)
        {
            System.out.println(e.getMessage());
            System.out.println("Prolog Parser Version 0.1:  Encountered errors during parse.");
        }
    }

}

PARSER_END(PrologParser)


/* WHITE SPACE */

SKIP :
{
  " "
| "\t"
| "\n"
| "\r"
| "\f"
}

/* COMMENTS */

MORE :
{
//  "%" : IN_SINGLE_LINE_COMMENT
//|
  "/*" : IN_MULTI_LINE_COMMENT
}

/*
<IN_SINGLE_LINE_COMMENT>
SPECIAL_TOKEN :
{
  <SINGLE_LINE_COMMENT: "\n" | "\r" | "\r\n" > : DEFAULT
}*/

SPECIAL_TOKEN : {

    < SINGLE_LINE_COMMENT: "%"(~["\n","\r"])* ("\n"|"\r"|"\r\n")? > }


<IN_MULTI_LINE_COMMENT>
SPECIAL_TOKEN :
{
  <MULTI_LINE_COMMENT: "*/" > : DEFAULT
}

<IN_SINGLE_LINE_COMMENT,IN_MULTI_LINE_COMMENT>
MORE :
{
  < ~[] >
}

/* RESERVED WORDS AND LITERALS */

TOKEN :
{
  < DYNAMIC: "dynamic" >
| < MULTIFILE: "multifile" >
| < INIT: "initialization" >
| < MODULE_TRANSPARENT : "module_transparent" >
| < VOLATILE : "volatile" >
}

/* OPERATORS */

TOKEN :
{
  < ASSIGN: "=" >
| < METAASSIGN: "=.." >
| < GT: ">" >
| < LT: "<" >
| < CUT: "!" >
| < ARROW: "-->" >
| < IF: "->" >
| < SOFTCUT: "*->" >
| < QUERY: "?-" >
| < CLAUSEDEF: ":-" >
| < COLON: ":" >
| < EQ: "==" >
| < EQ2: "=:=" >
| < EQ3: "=\\=" >
| < EQ4: "=@=" >
| < NEQ: "\\=" >
| < NEQ2: "\\==" >
| < IS: "is" >
| < LE: "<=" >
| < LE2: "=<" >
| < GE: ">=" >
| < GE2: "=>" >
| < NE: "!=" >
| < PLUS: "+" >
| < MINUS: "-" >
| < STAR: "*" >
| < NOTPROVABLE: "\\+" >
| < MOD: "mod" >
| < LSHIFT: "<<" >
| < RSIGNEDSHIFT: ">>" >
| < DOLLAR: "$" >
| < SLASH: "/">
| < POINTER: "^">
| < AT: "@">
| < DIVISION: "//">
| < BITAND: "/\\">
| < BITOR: "\\//">
| < BITNOT: "\\/">
| < BITXOR: "xor">
}


/* LITERALS */

TOKEN :
{
//  < ARITY_LITERAL: [<SLASH>] ["1"-"9"] (["0"-"9"])* >
//|
  < DECIMAL_LITERAL: ["0"-"9"] (["0"-"9"])* >
|
  < BIN_LITERAL: ["0"-"9"] "b" ["0"-"1"] (["0"-"1"])* >
|
  < OCT_LITERAL: ["0"-"9"] "o" ["0"-"7"] (["0"-"7"])* >
|
  < HEX_LITERAL: ["0"-"9"] "x" ["0"-"9","A"-"F","a"-"f"] (["0"-"9","A"-"F","a"-"f"])* >
|
  < FLOATING_POINT_LITERAL:
        (["0"-"9"])+ "." (["0"-"9"])+ (<EXPONENT>)? /*(["f","F","d","D"])?*/
//      | "." (["0"-"9"])+ (<EXPONENT>)? /*(["f","F","d","D"])?*/
      | (["0"-"9"])+ <EXPONENT> /*(["f","F","d","D"])?*/
      | (["0"-"9"])+ (<EXPONENT>)? /*["f","F","d","D"]*/
  >
|
  < #EXPONENT: ["e","E"] (["+","-"])? (["0"-"9"])+ >
|
  < CHARACTER_ATOM:
      "'"
      (   (~["\'","\\","\n","\r"])
        | ("\\"
            ( ["n","t","b","r","f","\\","'","\""]
            )
          )
        | ("''")
      )*
      "'"
  >
|
  < STRING_LITERAL:
      "\""
      (   (~["\"","\\"]) /*,"\n","\r"*/
        | ("\\"
            ( ["n","t","b","r","f","\\","'","\""]
            | ["0"-"7"] ( ["0"-"7"] )?
            | ["0"-"3"] ["0"-"7"] ["0"-"7"]
            )
          )
        | ("\"\"")
      )*
      "\""
  >
  |
    < ZERO_APO_REST: "0'" ~["'"] >
  
}

/* IDENTIFIERS */

TOKEN :
{
  < VARIABLE: (<UNDERLINE> | <UPPERLETTER>) (<DIGIT>|<UPPERLETTER>|<LOWERLETTER>|<UNDERLINE>)* >
| 
  < IDENTIFIER: (<LOWERLETTER>|<DOLLAR>)(<DIGIT>|<UPPERLETTER>|<LOWERLETTER>|<VARIABLE>)* >
|
  < #UNDERLINE:
      [
       "_"
      ]
  >
|

  < #UPPERLETTER:
      [
       "A"-"Z"
      ]
  >
|
  < #DIGIT:
      [
       "0"-"9"
      ]
  >
|
  < #LOWERLETTER:
      [
       "a"-"z"
      ]
  >
}


/* SEPARATORS */

TOKEN :
{
  < LPAREN: "(" >
| < RPAREN: ")" >
| < LBRACE: "{" >
| < RBRACE: "}" >
| < LBRACKET: "[" >
| < RBRACKET: "]" >
| < SEMICOLON: ";" >
| < COMMA: "," >
| < DOT: "." >
| < LISTSEP: "|" >
}

/*****************************************
 * THE JAVA LANGUAGE GRAMMAR STARTS HERE *
 *****************************************/

/*
 * Program structuring syntax follows.
 */

void CompilationUnit() :
{}
{
   try{
	(Member())*

  <EOF>
	   }
	     catch (ParseException e) {
	    error_skipto(DOT);
	  }
	  
}

void Member() #void:
{}
{
	try{
	  ( 
	    LOOKAHEAD(2)
	    NamedCall() 
	  |
	    Call()
	  | 
	    Clause()
	   )
	   }
	     catch (ParseException e) {
	    error_skipto(DOT);
	  }
}

void Functor() :
{    Token token;
}
{
    ( LOOKAHEAD(2) token=<IDENTIFIER> 
      {jjtThis.setModuleName(token.image.toString());} <COLON> )?
    (
    token=<IDENTIFIER> 
    {jjtThis.setName(token.image.toString()); }
    | token=<DYNAMIC> 
    {jjtThis.setName(token.image.toString()); }
    | token=<MULTIFILE> 
    {jjtThis.setName(token.image.toString()); }
    | token=<MODULE_TRANSPARENT> 
    {jjtThis.setName(token.image.toString()); }
    | token=<VOLATILE> 
    {jjtThis.setName(token.image.toString()); }
//    | token=<INIT> 
//    {jjtThis.setName(token.image.toString()); }
    | token=<POINTER> 
    {jjtThis.setName(token.image.toString()); }
    | token=<AT> 
    {jjtThis.setName(token.image.toString()); }

//    | token=<IS> 
//    {jjtThis.setName(token.image.toString()); }
//    | token=<MOD> 
//    {jjtThis.setName(token.image.toString()); }
    | token=<CHARACTER_ATOM>
    {jjtThis.setName(token.image.toString()); }
	)
}


/* ************* ********** ************* */
/* *************  to delete ************* */
/* ************* ********** ************* */

void FunctorVariableModule() :
{    Token token;}
{
    ( LOOKAHEAD(3) Variable() <COLON> ) ?
    (
    token=<IDENTIFIER> 
    {jjtThis.setName(token.image.toString()); }
    | token=<DYNAMIC> 
    {jjtThis.setName(token.image.toString()); }
    | token=<MULTIFILE> 
    {jjtThis.setName(token.image.toString()); }
    | token=<MODULE_TRANSPARENT> 
    {jjtThis.setName(token.image.toString()); }
    | token=<VOLATILE> 
    {jjtThis.setName(token.image.toString()); }
//    | token=<INIT> 
//    {jjtThis.setName(token.image.toString()); }
    | token=<IS> 
    {jjtThis.setName(token.image.toString()); }
    | token=<MOD> 
    {jjtThis.setName(token.image.toString()); }
    | token=<CHARACTER_ATOM>
    {jjtThis.setName(token.image.toString()); }
	)
}

void Variable() :
{
    Token token;
}
{
    token=<VARIABLE>
    {
       jjtThis.setName(token.image.toString());
       
    }
}

void Identifier() :
{
    Token token;
}
{
    (
//    token=<POINTER> 
//    {jjtThis.setName(token.image.toString()); }
//    token=<AT> 
//    {jjtThis.setName(token.image.toString()); }
    token=<IDENTIFIER>
    {jjtThis.setName(token.image.toString()); }
    | token=<DYNAMIC> 
    {jjtThis.setName(token.image.toString()); }
    | token=<MULTIFILE> 
    {jjtThis.setName(token.image.toString()); }
    | token=<MODULE_TRANSPARENT> 
    {jjtThis.setName(token.image.toString()); }
    | token=<VOLATILE> 
    {jjtThis.setName(token.image.toString()); }
    
//    | token=<IS> 
//    {jjtThis.setName(token.image.toString()); }
//    | token=<MOD> 
//    {jjtThis.setName(token.image.toString()); }
    | token=<CHARACTER_ATOM> 
    {jjtThis.setName(token.image.toString()); }

	)

}


void NamedCall() :
{Token token;}
{
  (token=<QUERY>|token=<CLAUSEDEF>) 
  (token=<DYNAMIC>|token=<MULTIFILE>|token=<MODULE_TRANSPARENT>|token=<VOLATILE>){jjtThis.setKind(token.kind);} PredicateSignature() (<COMMA> PredicateSignature())* 
  token=<DOT> 
}


void Call() :
{Token token;}
{
  (token=<QUERY>|token=<CLAUSEDEF>)  (<INIT> {jjtThis.setInitialization(true);} )? 
  Body() {jjtThis.setBody( (ASTBody) jjtree.peekNode() );}
  token=<DOT> 
}


void PredicateSignature() :
{Token token;}
{
    ( <LPAREN>(Functor()|BinaryOp()) <RPAREN>| Functor())<SLASH>token=<DECIMAL_LITERAL>
    {jjtThis.setArity(token.image.toString());}
}

void Clause() :
{Token token;}
{
	(LOOKAHEAD(2) token=<IDENTIFIER>  <COLON> {jjtThis.setModule(token.image.toString());})?
	(
	 <LPAREN> 	
	   Head() {jjtThis.setHead( (ASTHead) jjtree.peekNode() );}
      (	
        (<ARROW>| <CLAUSEDEF>) 
      	Body() {jjtThis.setBody( (ASTBody) jjtree.peekNode() );}
      )?
      <RPAREN> 
	 | 
	  Head() {jjtThis.setHead( (ASTHead) jjtree.peekNode() );}
      (	
        (<ARROW>| <CLAUSEDEF>) 
      	Body() {jjtThis.setBody( (ASTBody) jjtree.peekNode() );}
      )?
	)
	  token=<DOT> 
}

void Head() :
{}
{
	Identifier() {jjtThis.setName(((ASTIdentifier)jjtree.peekNode()).getName());}
	(
	  PredicateArgs() {jjtThis.setArguments( (ASTPredicateArgs) jjtree.peekNode() );}
	)?
}

void PredicateArgs() :
{}
{
    <LPAREN> BodyElement() (<COMMA> BodyElement())* <RPAREN>
}


void Term() #void :
{}
{
    LOOKAHEAD(4) Compound() /*LOOKAHEAD(3) DividedAtom() |*/ 
    | Cut() 
    | Parenthesis() 
    | Identifier()
    | LOOKAHEAD(1) IntAtom()
    | FloatAtom()
    | StringAtom()
    | BinaryOp()
    | RestTokens()
    | Variable() 
    | List()
    | Braces()
}

void TermWithoutOp() #void :
{}
{
    LOOKAHEAD(4) Compound() /*LOOKAHEAD(3) DividedAtom() |*/ 
    | Cut() 
    | Parenthesis() 
    | Identifier()
    | LOOKAHEAD(1) IntAtom()
    | FloatAtom()
    | StringAtom()
    | RestTokens()
    | Variable() 
    | List()
    | Braces()
}

void Compound() :
{ASTSequence sequence;}
{
	(// TODO: what does the pointer mean?
		Atom() (<POINTER>)? sequence=Sequence() {jjtThis.setArgs( sequence );}
	| 
		Variable() <POINTER> sequence=Sequence()	{jjtThis.setArgs( sequence );}
	)
}	

void Cut() :
{Token token;}
{
	token=<CUT> 
}

/*
void DividedAtom():
{}
{
    ((LOOKAHEAD(3) SimpleAtom() | Variable())) (BinaryOp() (SimpleAtom() | Variable()))+
}
*/
ASTSequence Sequence() :
{Token token;}
{
   token=<LPAREN>
   BodyElement() ( <COMMA> BodyElement())*  <RPAREN>
   {return jjtThis;}
}

void List() : 
{ Token token; }
{
    LOOKAHEAD(2) token=<LBRACKET>  <RBRACKET> | token=<LBRACKET>  BodyElement() (<COMMA> BodyElement())* (<LISTSEP> (Variable() | List()))* <RBRACKET>
}

void Braces() : 
{    Token token; }
{
   token=<LBRACE>  BodyElement() ((<COMMA>|<SEMICOLON>)BodyElement())* <RBRACE>
}

void Parenthesis() :
{ Token token; }
{
   token=<LPAREN>  BodyElement() ((<COMMA>|<SEMICOLON>)BodyElement())* <RPAREN>
}

void Atom() #void :
{ Token token; }
{
    ( LOOKAHEAD(2) Functor() 
//    | LOOKAHEAD(2) FunctorVariableModule()
    | LOOKAHEAD(1) IntAtom()
    | FloatAtom()
    | StringAtom()
    | BinaryOp()
    | RestTokens()
    )
}

/*
void SimpleAtom() #void :
{ Token token; }
{
    ( 
      Identifier()
    | LOOKAHEAD(1) IntAtom()
    | FloatAtom()
    )
}
*/


void RestTokens() :
{}
{
   (  
//      token=<SEMICOLON>
//    | token=<COMMA>
     token=<CLAUSEDEF>
    | token=<DOLLAR>
    | token=<ZERO_APO_REST>
   )
  { jjtThis.setName(token.image.toString()); }  
}



void IntAtom() :
{ Token token; }
{
    (<MINUS> (token=<DECIMAL_LITERAL> | token=<BIN_LITERAL>  | token=<OCT_LITERAL>  | token=<HEX_LITERAL> )
      {jjtThis.setName("-"+token.image.toString()); }  
    | (token=<DECIMAL_LITERAL> | token=<BIN_LITERAL>  | token=<OCT_LITERAL>  | token=<HEX_LITERAL> )
      { jjtThis.setName(token.image.toString()); }   
    )
}

void FloatAtom() :
{ Token token; }
{
    token=<FLOATING_POINT_LITERAL> 
    { jjtThis.setName(token.image.toString()); }
}


void StringAtom() :
{ Token token; }
{
    token=<STRING_LITERAL>
    { jjtThis.setName(token.image.toString()); }
}

void CharAtom() :
{ Token token; }
{
    token=<CHARACTER_ATOM>
    { jjtThis.setName(token.image.toString()); }
}

void Body() :
{Token token;}
{
    BodyElement() ( Separator() BodyElement())* 
}

void Separator() :
{Token token;}
{
 	(token=<COMMA>|token=<SEMICOLON>) 
	{jjtThis.setName(token.image.toString()); }
}
void BodyElement() #void :
{Token token;}
{
    ( <NOTPROVABLE> )* 
    (
    	LOOKAHEAD(2)(
	    	(token=<MINUS> | token=<PLUS>) 
	    	(TermWithoutOp()|{}) 
	    	{jjtree.peekNode().setFlag(token);} 
	    ) 
	    |Term()
	 ) // TODO: double occurance of plus or minus  is allowed!
     (
     	BinaryOp() 
     	( <NOTPROVABLE> )* 
	     Term()
     )* // TODO: priorities and not provables!
     
}



void BinaryOp() :
{Token token;}
{
( 
  token=<ARROW>
| token=<ASSIGN>
| token=<METAASSIGN>
| token=<GT>
| token=<LT>
//| token=<QUERY>
| token=<EQ>
| token=<EQ2>
| token=<EQ3>
| token=<EQ4>
| token=<NEQ>
| token=<NEQ2>
| token=<IS>
| token=<LE>
| token=<GE>
| token=<LE2>
| token=<GE2>
| token=<COLON>
| token=<NE>
| token=<PLUS>
| token=<MINUS>
| token=<STAR>
| token=<LSHIFT>
| token=<RSIGNEDSHIFT>
| token=<IF>
| token=<MOD>
| token=<SOFTCUT>
| token=<SLASH>
| token=<BITAND>
| token=<DIVISION>
| token=<BITOR>
| token=<BITNOT>
| token=<BITXOR>
//  { if(!(token.image.equals("mod") || token.image.equals("is"))) {jj_consume_token(-1); throw new ParseException();}}
)


{}
}

