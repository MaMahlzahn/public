/* Generated By:JJTree: Do not edit this line. SimpleNode.java */

package org.cs3.pl.parser;

/**
 * @author windeln
 *
 * To change the template for this generated type comment go to
 * Window - Preferences - Java - Code Generation - Code and Comments
 */
public class SimpleNode implements Node {
	protected Node parent;
	public Node[] children;
	protected int id;
	protected PrologParser parser;
	private Token firstToken;
	private Token lastToken;
	private boolean hasMinusPrefix = false;
	private boolean hasPlusPrefix = false;
	
	public SimpleNode(int i) {
		id = i;
	}
	
	public SimpleNode(PrologParser p, int i) {
		this(i);
		parser = p;
	}
	
	public void jjtOpen() {
	}
	
	public void jjtClose() {
	}
	
	public void jjtSetParent(Node n) { parent = n; }
	public Node jjtGetParent() { return parent; }
	
	public void jjtAddChild(Node n, int i) {
		if (children == null) {
			children = new Node[i + 1];
		} else if (i >= children.length) {
			Node c[] = new Node[i + 1];
			System.arraycopy(children, 0, c, 0, children.length);
			children = c;
		}
		children[i] = n;
	}
	
	public Node jjtGetChild(int i) {
		return children[i];
	}
	
	public int jjtGetNumChildren() {
		return (children == null) ? 0 : children.length;
	}
	
	/** Accept the visitor. **/
	public Object jjtAccept(PrologParserVisitor visitor, Object data) {
		return visitor.visit(this, data);
	}
	
	/** Accept the visitor. **/
	public Object childrenAccept(PrologParserVisitor visitor, Object data) {
		if (children != null) {
			for (int i = 0; i < children.length; ++i) {
				children[i].jjtAccept(visitor, data);
			}
		}
		return data;
	}
	
	/* You can override these two methods in subclasses of SimpleNode to
	 customize the way the node appears when the tree is dumped.  If
	 your output uses more than one line you should override
	 toString(String), otherwise overriding toString() is probably all
	 you need to do. */
	
	public String toString() { return PrologParserTreeConstants.jjtNodeName[id]; }
	public String toString(String prefix) { return prefix + toString(); }
	
	/* Override this method if you want to customize how the node dumps
	 out its children. */
	
	public void dump(String prefix) {
		System.out.println(toString(prefix));
		if (children != null) {
			for (int i = 0; i < children.length; ++i) {
				SimpleNode n = (SimpleNode)children[i];
				if (n != null) {
					n.dump(prefix + " ");
				}
			}
		}
	}
	/**
	 * @return Returns the token.
	 */
	public Token getFirstToken() {
			return firstToken;
	}
	public Token getStartToken(){
		return getFirstToken();
	}
	/**
	 * @return Returns the last token that is part of this node.
	 */
	public Token getLastToken() {
			return lastToken;
	}
	
	/**
	 * @return Returns the first token that is NOT part of this node.
	 */	
	 public Token getEndToken(){
		 return getLastToken().next;
	 }
	
	/* (non-Javadoc)
	 * @see org.cs3.pl.parser.Node#setFlag(org.cs3.pl.parser.Token)
	 */
	public void setFlag(Token token) {
		if(token.image.charAt(0) == '-')
			hasMinusPrefix = true;
		else if(token.image.charAt(0) == '+')
			hasPlusPrefix = true;
		
	}
	/**
	 * @return Returns the hasMinusPrefix.
	 */
	public boolean isHasMinusPrefix() {
		return hasMinusPrefix;
	}
	/**
	 * @return Returns the hasPlusPrefix.
	 */
	public boolean isHasPlusPrefix() {
		return hasPlusPrefix;
	}
	
	
	/**
	 * 
	 * Retrieves the comments above this prolog element starting
	 * with the first occurance of <b>predname</b>.
	 * 
	 * @param predname specifies the starting point of the comment.
	 * 		
	 * @see org.cs3.pl.parser.Node#getComment(java.lang.String)
	 */
	
	public String getComment(String predname) {
		Token token = getStartToken().specialToken;
		if(token != null)
		   if(token.image.startsWith("/*"))
			return makeSwiConformString(predname,token.image,token.image.length(),2,2);
		   else if(token.image.startsWith("%")){
		   		String buf = new String();
		   		do {
		   			buf = token.image.substring(1) + buf;
		   			token = token.specialToken;
		   		} while(token != null);
		   		return makeSwiConformString(predname,buf.toString(),buf.length(),1,0);
		   }
		return null;
				
	}

	/**
	 * @param string
	 * @return
	 */
	private String makeSwiConformString(String predname, String str, int len, int removeStart, int removeEnd) {
//		int i = begin;

//		while(isWhileSpace(str.charAt(i)) && i < end) 
//			i++;
		int start;
		if (predname == null)
			start = removeStart;
		else 
			start = str.indexOf(predname);
		if(start > -1)
			return "\""+str.substring(start,len-removeEnd).replaceAll("\"","\\\\\"")+"\"";
		return null;
	}

	/**
	 * @param c
	 * @return
	 */
	private boolean isWhileSpace(char c) {
		switch(c) {
			case '\n':
			case '\r':
			case '\t':
			case ' ':
				return true;
			default:
				return false;
		}
	}

	public void setFirstToken(Token firstToken) {
		this.firstToken = firstToken;
	}

	public void setLastToken(Token lastToken) {
		this.lastToken = lastToken;
	}

	public String getImage(){
		StringBuffer buf = new StringBuffer();		
		for(Token t = getStartToken();t!=getEndToken();t=t.next){
			buf.append(t.image);
		}
		return buf.toString();
	}
}

