/* Generated By:JJTree: Do not edit this line. ASTString.java */

package org.cs3.pl.parser.internal.term;

public class ASTString extends SimpleNode {
	private String value;

	public ASTString(int id) {
		super(id);
	}

	public ASTString(PrologTermParser p, int id) {
		super(p, id);
	}

	/** Accept the visitor. * */
	public Object jjtAccept(PrologTermParserVisitor visitor, Object data) {
		return visitor.visit(this, data);
	}

	public String toString() {
		return super.toString() + " (" + getImage() + ")";
	}

	protected void synthesizeImage(StringBuffer sb) {
		sb.append("\"");
		sb.append(getValue());
		sb.append("\"");

	}

	public String getLabel() {	
		return "'.'";
	}
	public int getArity(){
		return 2;
	}
	private String getValue() {
		if (value == null) {
			value = getImage();
			value = value.substring(1);
			value = value.substring(0, value.length() - 1);
		}
		return value;
	}

	public SimpleNode createShallowCopy() {
		ASTString copy = new ASTString(parser, id);
		copy.copy = true;
		copy.value = getValue();
		return copy;
	}

	public SimpleNode toCanonicalTerm(boolean linked, boolean deep) {

		ASTInfixOperator comma = new ASTInfixOperator(parser,
				PrologTermParserTreeConstants.JJTINFIXOPERATOR);
		comma.value = ",";
		comma.copy = true;
		ASTCharacters label = new ASTCharacters(parser,
				PrologTermParserTreeConstants.JJTCHARACTERS);
		label.copy = true;
		label.value = ".";
		if (linked) {
			label.original = this;
			comma.original = this;
		}

		byte[] bytes = getValue().getBytes();
		SimpleNode r = new ASTListTerm(parser,
				PrologTermParserTreeConstants.JJTLISTTERM);
		r.copy = true;
		if (linked) {
			r.original = this;
		}
		for (int i = bytes.length - 1; i >= 0; i--) {
			ASTInteger v = new ASTInteger(parser,
					PrologTermParserTreeConstants.JJTINTEGER);
			v.copy = true;
			if (linked) {
				v.original = this;
			}
			v.value = "" + (int) bytes[i];

			ASTInfixTerm args = new ASTInfixTerm(parser,
					PrologTermParserTreeConstants.JJTINFIXTERM);
			args.copy = true;
			if (linked) {
				args.original = this;
			}
			args.children = new Node[3];
			args.children[0] = (Node) comma.clone(linked, deep);
			args.children[1] = v;
			args.children[2] = r;

			r = new ASTCompoundTerm(parser,
					PrologTermParserTreeConstants.JJTCOMPOUNDTERM);
			r.copy = true;
			if (linked) {
				r.original = this;
			}
			r.children = new Node[2];
			r.children[0] = (Node) label.clone(linked, deep);
			r.children[1] = args;
		}
		return r;
	}
}
