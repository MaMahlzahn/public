/*@bgen(jjtree) Generated By:JJTree: Do not edit this line. termparser.jj */
/*@egen*//**
* Example of JJTree file
*/

options {
  STATIC=false;                                                                                                                                   
  DEBUG_PARSER=false;
  DEBUG_LOOKAHEAD=false;
  DEBUG_TOKEN_MANAGER=false;
  OPTIMIZE_TOKEN_MANAGER=true;                         
  LOOKAHEAD=1;
  COMMON_TOKEN_ACTION=true;
}

PARSER_BEGIN(PrologTermParser)
package org.cs3.pl.parser.internal.term;
import java.io.InputStream;
import java.io.FileInputStream;
import java.io.File;
import java.io.FileNotFoundException;
import java.util.List;
import java.util.ArrayList;

class PrologTermParser/*@bgen(jjtree)*/implements PrologTermParserTreeConstants/*@egen*/ {/*@bgen(jjtree)*/
  protected JJTPrologTermParserState jjtree = new JJTPrologTermParserState();

/*@egen*/
	public OPS ops = new OPS();
	
	boolean test(Token t1, Token t2) {
		return t1.beginOffset == t2.endOffset;
//		System.err.println("begin: "+t1.image +","+ t1.beginOffset + ", end: "+ t2.endOffset);
//		return true;
	}
	
	void jjtreeOpenNodeScope(Node n)
    {
    	Token t = getToken(1);
    	System.err.println("open node of type "+PrologTermParserTreeConstants.jjtNodeName[((SimpleNode)n).id]);
    	//System.err.prinln("   first token: "+t.image+" at line "+t.beginLine+", column "+t.beginColumn+".");
      ((SimpleNode)n).setFirstToken(t);
      
    }

    void jjtreeCloseNodeScope(Node n)
    {
      Token t = getToken(0);
    	//System.err.prinln("closing node of type "+n);
    	//System.err.prinln("   last token: "+t.image+" at line "+t.beginLine+", column "+t.beginColumn+".");      
      ((SimpleNode)n).setLastToken(t);
      
      
	  
	  	//need to "manualy" figure out the start token, as node scope hooks are
		//called "to late" for nodes like ASTInfixTerm 
		//if the nodes children have already been poped, this should work:
		SimpleNode s = (SimpleNode)n;
		if(s.jjtGetNumChildren()>0){
			 SimpleNode firstChild = (SimpleNode)s.jjtGetChild(0);
			 s.setFirstToken(firstChild.getFirstToken());
		}
		System.err.println("created: "+ s+" : "+s.getImage());
		
		
		if(n instanceof ASTInfixTerm){
		 ((ASTInfixTerm)n).flatten();
 	  
	  }
    }
	private List errors = new ArrayList();
	
	public List getErrors() {
		return errors;
	}
	public void error_skipto(int kind) {
	  ParseException e = generateParseException();  
	  errors.add(e);
	  Token t;
	  do {
	    t = getNextToken();
	  } while (t.kind != kind && t.kind != EOF);
	}
	public ASTCompilationUnit getASTRoot(){
		return (ASTCompilationUnit) jjtree.rootNode();
  	}
  public static void main(String args[]) throws FileNotFoundException {
	InputStream stream = null;
  	if(args==null||args.length==0){	
	    //System.err.println("Reading from standard input...");
	    stream=System.in;
  	}
  	else{
  		stream=PrologTermParser.class.getResourceAsStream(args[0]);
  	}
    PrologTermParser t = new PrologTermParser(stream);
    try {
      SimpleNode n = t.CompilationUnit();
      n.dump("");
      System.err.println("Thank you.");
    } catch (Exception e) {
      System.err.println("Oops.");
      System.err.println(e.getMessage());
      e.printStackTrace();
    }
  }
  
}

PARSER_END(PrologTermParser)
TOKEN_MGR_DECLS:{
void CommonTokenAction(Token t){
	 t.beginOffset = input_stream.getBeginOffset();
 	 t.endOffset = input_stream.getEndOffset();
}
}
SKIP :
{
<WHITESPACE: [" ", "\t","\n","\r"]>
}


/* COMMENTS */

MORE :
{
  "/*" : IN_MULTI_LINE_COMMENT
}


SPECIAL_TOKEN : {

    < SINGLE_LINE_COMMENT: "%"(~["\n","\r"])* ("\n"|"\r"|"\r\n")? > }


<IN_MULTI_LINE_COMMENT>
SPECIAL_TOKEN :
{
  <MULTI_LINE_COMMENT: "*/" > : DEFAULT
}

<IN_SINGLE_LINE_COMMENT,IN_MULTI_LINE_COMMENT>
MORE :
{
  < ~[] >
}
TOKEN :
{
  <OPERATOR: (<OPBODY>|("'" <OPBODY> "'") ) >
  |<#OPBODY:
		("xor"
		|"@"
		|"^"
		|"-"
		|"-"
		|"mod"
		|"meta_predicate"
		|"discontiguous"
		|"thread_local"
		|"//"
		|"?"
		|"?"
		|"/"
		|"*"
		|">>"
		|"|"
		|"->"
		|"<"
		|"/\\"
		|">"
		|"\\+"
		|"\\=="
		|">="
		|"rem"
		|"*->"
		|"=<"
		|"**"
		|"+"
		|"+"
		|":="
		|"\\="
		|"\\"
		|":"
		|"=.."
		|"dynamic"
		|","
		|"=="
		|"$"
		|"=:="
		|"initialization"
		|"<<"
		|"=\\="
		|"@>="
		|"\\=@="
		|"-->"
		|"?-"
		|"@<"
		|"multifile"
		|"@=<"
		|":-"
		|":-"
		|"is"
		|"volatile"
		|"\\/"
		|"="
		|";"
		|"module_transparent"
		|"=@="
		|"@>")
		>
|
  < DECIMAL_LITERAL: ("0'" ~[])|(["0"-"9"] (["0"-"9"])*) >
|
  < BIN_LITERAL: ["0"-"9"] "b" ["0"-"1"] (["0"-"1"])* >
|
  < OCT_LITERAL: ["0"-"9"] "o" ["0"-"7"] (["0"-"7"])* >
|
  < HEX_LITERAL: ["0"-"9"] "x" ["0"-"9","A"-"F","a"-"f"] (["0"-"9","A"-"F","a"-"f"])* >
|
  < FLOATING_POINT_LITERAL:
        (["0"-"9"])+ "." (["0"-"9"])+ (<EXPONENT>)? /*(["f","F","d","D"])?*/
//      | "." (["0"-"9"])+ (<EXPONENT>)? /*(["f","F","d","D"])?*/
      | (["0"-"9"])+ <EXPONENT> /*(["f","F","d","D"])?*/
      | (["0"-"9"])+ (<EXPONENT>)? /*["f","F","d","D"]*/
  >
|
  < #EXPONENT: ["e","E"] (["+","-"])? (["0"-"9"])+ >
 | < CHARACTER_ATOM:
      "'"
      (   (~["\'","\\","\n","\r"])
        | ("\\"
            ( ["n","t","b","r","f","\\","'","\""]
            )
          )
        | ("''")
      )*
      "'" 
  >

|
  < STRING_LITERAL:
      "\""
      (   (~["\"","\\"]) /*,"\n","\r"*/
        | ("\\"
            ( ["n","t","b","r","f","\\","'","\""]
            | ["0"-"7"] ( ["0"-"7"] )?
            | ["0"-"3"] ["0"-"7"] ["0"-"7"]
            )
          )
        | ("\"\"")
      )*
      "\""
  >
  //|
    //< ZERO_APO_REST: "0'" (~["'"])* >
  
}
/* IDENTIFIERS */

TOKEN :
{
  <FAKEEOF: "EOF" ~[]>
|
  < VARIABLE: (<UNDERLINE> | <UPPERLETTER>) (<DIGIT>|<UPPERLETTER>|<LOWERLETTER>|<UNDERLINE>)* >
| 
  < IDENTIFIER: (<LOWERLETTER>|<DOLLAR>)(<DIGIT>|<UPPERLETTER>|<LOWERLETTER>|<VARIABLE>)* >

|
  < #UNDERLINE:
      [
       "_"
      ]
  >
|

  < #UPPERLETTER:
      [
       "A"-"Z"
      ]
  >
|
  < #DIGIT:
      [
       "0"-"9"
      ]
  >
|
  < #LOWERLETTER:
      [
       "a"-"z"
      ]
  >
 |

  < DOLLAR  :"$">
 |
  < CUT :"!">
  |
  < DOT :".">


}


SimpleNode CompilationUnit() : {/*@bgen(jjtree) CompilationUnit */
  ASTCompilationUnit jjtn000 = new ASTCompilationUnit(this, JJTCOMPILATIONUNIT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) CompilationUnit */
  try {
/*@egen*/
  (
  try{
  	Member() 
  } catch (ParseException e) {
  		e.printStackTrace();
	    error_skipto(DOT);
	    //pop nodes from the stack down to the last
	    //successfully parsed term
		ops.clear();
		while(jjtree.nodeArity()>0 &&!(jjtree.peekNode() instanceof ASTMember)){
			
			//System.err.println("popped: "+jjtree.popNode());
		}
//		System.err.println("next i will read: "+getToken(1));
  }
  )*
  (<EOF>|<FAKEEOF>)/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
    jjtreeCloseNodeScope(jjtn000);
  }
/*@egen*/
  { return jjtn000; }/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
      jjtreeCloseNodeScope(jjtn000);
    }
  }
/*@egen*/
  
}

void Member():{/*@bgen(jjtree) Member */
  ASTMember jjtn000 = new ASTMember(this, JJTMEMBER);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) Member */
        try {
/*@egen*/
	Term() <DOT>/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
            jjtreeCloseNodeScope(jjtn000);
          }
        }
/*@egen*/
}
void Term()      : 
{String opImage;}
{

	PrefixBoundTerm()
	(
		LOOKAHEAD({
			jjtree.peekNode()!=null
			&&ops.isValidRHInfixOp(getToken(1).image,((SimpleNode)jjtree.peekNode()).getPrecedence())
		})
		InfixOperator()
		{ 
			opImage=getToken(0).image;
			ops.pushInfixOp(opImage);
		} 
		Term()/*@bgen(jjtree) #InfixTerm( 3) */
                {
                  ASTInfixTerm jjtn001 = new ASTInfixTerm(this, JJTINFIXTERM);
                  boolean jjtc001 = true;
                  jjtree.openNodeScope(jjtn001);
                  jjtreeOpenNodeScope(jjtn001);
                }
                try {
/*@egen*//*@bgen(jjtree)*/
                {
                  jjtree.closeNodeScope(jjtn001,  3);
                  jjtc001 = false;
                  jjtreeCloseNodeScope(jjtn001);
                }
/*@egen*/
		{
			ops.popOp();
		}/*@bgen(jjtree)*/
                } finally {
                  if (jjtc001) {
                    jjtree.closeNodeScope(jjtn001,  3);
                    jjtreeCloseNodeScope(jjtn001);
                  }
                }
/*@egen*/
	)* 
	
}




void PrefixBoundTerm()      :{}
{
	(		
		LOOKAHEAD(Atom() "(",{
					test(getToken(2),getToken(1)) &&
					!",".equals(getToken(1).image)}) 
			CompoundTerm()
			
		|LOOKAHEAD(Atom() (","|")"|"]"|"}"|".")) Atom()
		|LOOKAHEAD(<OPERATOR> ,{
					ops.isValidRHPrefixOp(getToken(1).image, getToken(2).image) 
				   	})
			PrefixOperator()
			{				
				ops.pushPrefixOp(getToken(0).image);
			}
			Term()/*@bgen(jjtree) #PrefixTerm( 2) */
                        {
                          ASTPrefixTerm jjtn001 = new ASTPrefixTerm(this, JJTPREFIXTERM);
                          boolean jjtc001 = true;
                          jjtree.openNodeScope(jjtn001);
                          jjtreeOpenNodeScope(jjtn001);
                        }
                        try {
/*@egen*//*@bgen(jjtree)*/
                        {
                          jjtree.closeNodeScope(jjtn001,  2);
                          jjtc001 = false;
                          jjtreeCloseNodeScope(jjtn001);
                        }
/*@egen*/
			{
				ops.popOp();
			}/*@bgen(jjtree)*/
                        } finally {
                          if (jjtc001) {
                            jjtree.closeNodeScope(jjtn001,  2);
                            jjtreeCloseNodeScope(jjtn001);
                          }
                        }
/*@egen*/
		
		|Atom()
		|ParanthesisTerm()
		|BracesTerm()
		|ListTerm()
		|Number()
		|String()
		|Variable()
	)
	
}

void BracesTerm() :
{/*@bgen(jjtree) BracesTerm */
  ASTBracesTerm jjtn000 = new ASTBracesTerm(this, JJTBRACESTERM);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) BracesTerm */
        try {
/*@egen*/
	"{" 
	{ops.pushReset();}
	Term() 
	{ops.popOp();}
	"}"/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
            jjtreeCloseNodeScope(jjtn000);
          }
        }
/*@egen*/
}

void ListTerm() :
{/*@bgen(jjtree) ListTerm */
  ASTListTerm jjtn000 = new ASTListTerm(this, JJTLISTTERM);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) ListTerm */
        try {
/*@egen*/
	"[" 
	{ops.pushReset();}
	(Term())?
	{ops.popOp();}
	"]"/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
            jjtreeCloseNodeScope(jjtn000);
          }
        }
/*@egen*/
}

void ParanthesisTerm() :
{/*@bgen(jjtree) ParanthesisTerm */
  ASTParanthesisTerm jjtn000 = new ASTParanthesisTerm(this, JJTPARANTHESISTERM);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) ParanthesisTerm */
        try {
/*@egen*/
	"(" 
	{ops.pushReset();}
	Term() 
	{ops.popOp();}
	")"/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
            jjtreeCloseNodeScope(jjtn000);
          }
        }
/*@egen*/
}
void CompoundTerm() :
{/*@bgen(jjtree) CompoundTerm */
  ASTCompoundTerm jjtn000 = new ASTCompoundTerm(this, JJTCOMPOUNDTERM);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) CompoundTerm */
        try {
/*@egen*/
	Atom()
	"("
	{ops.pushReset();}
	Term() 
	{ops.popOp();}
	")"/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
            jjtreeCloseNodeScope(jjtn000);
          }
        }
/*@egen*/
}


void Atom()      : {}
{
	Cut()| Identifier()|Characters()
	
}
void Cut() :{/*@bgen(jjtree) Cut */
  ASTCut jjtn000 = new ASTCut(this, JJTCUT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) Cut */
        try {
/*@egen*/
	<CUT>/*@bgen(jjtree)*/
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
            jjtreeCloseNodeScope(jjtn000);
          }
        }
/*@egen*/
}
void Number()      :{}
{
	Integer()|Float()
}
void String() :{/*@bgen(jjtree) String */
  ASTString jjtn000 = new ASTString(this, JJTSTRING);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) String */
        try {
/*@egen*/
	<STRING_LITERAL>/*@bgen(jjtree)*/
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
            jjtreeCloseNodeScope(jjtn000);
          }
        }
/*@egen*/
}

void Variable() :{/*@bgen(jjtree) Variable */
  ASTVariable jjtn000 = new ASTVariable(this, JJTVARIABLE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) Variable */
        try {
/*@egen*/
	<VARIABLE>/*@bgen(jjtree)*/
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
            jjtreeCloseNodeScope(jjtn000);
          }
        }
/*@egen*/
}


void Identifier() : {/*@bgen(jjtree) Identifier */
  ASTIdentifier jjtn000 = new ASTIdentifier(this, JJTIDENTIFIER);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) Identifier */
        try {
/*@egen*/	
	<OPERATOR>
	|  <IDENTIFIER>
	|<DOT>/*@bgen(jjtree)*/
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
            jjtreeCloseNodeScope(jjtn000);
          }
        }
/*@egen*/
  
}

void Integer() : {/*@bgen(jjtree) Integer */
  ASTInteger jjtn000 = new ASTInteger(this, JJTINTEGER);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) Integer */
  try {
/*@egen*/
  <DECIMAL_LITERAL>|<BIN_LITERAL>|<OCT_LITERAL>|<HEX_LITERAL>/*@bgen(jjtree)*/
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
      jjtreeCloseNodeScope(jjtn000);
    }
  }
/*@egen*/
}

void Float() :{/*@bgen(jjtree) Float */
  ASTFloat jjtn000 = new ASTFloat(this, JJTFLOAT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) Float */
        try {
/*@egen*/
	<FLOATING_POINT_LITERAL>/*@bgen(jjtree)*/
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
            jjtreeCloseNodeScope(jjtn000);
          }
        }
/*@egen*/
}

void Characters() :{/*@bgen(jjtree) Characters */
  ASTCharacters jjtn000 = new ASTCharacters(this, JJTCHARACTERS);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) Characters */
        try {
/*@egen*/
	<CHARACTER_ATOM>/*@bgen(jjtree)*/
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
            jjtreeCloseNodeScope(jjtn000);
          }
        }
/*@egen*/
}


void PrefixOperator() :{/*@bgen(jjtree) PrefixOperator */
  ASTPrefixOperator jjtn000 = new ASTPrefixOperator(this, JJTPREFIXOPERATOR);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) PrefixOperator */
        try {
/*@egen*/
	<OPERATOR>/*@bgen(jjtree)*/
        {
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
          jjtreeCloseNodeScope(jjtn000);
        }
/*@egen*/
	{	Token t = getToken(0);
//  	System.err.println("Operator "+t.image+" at line "+t.beginLine+" col "+t.beginColumn+" was interpreted as Prefix Operator.");
  }/*@bgen(jjtree)*/
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
            jjtreeCloseNodeScope(jjtn000);
          }
        }
/*@egen*/
}


void InfixOperator() :{/*@bgen(jjtree) InfixOperator */
  ASTInfixOperator jjtn000 = new ASTInfixOperator(this, JJTINFIXOPERATOR);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtreeOpenNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) InfixOperator */
        try {
/*@egen*/
	<OPERATOR>/*@bgen(jjtree)*/
        {
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
          jjtreeCloseNodeScope(jjtn000);
        }
/*@egen*/
	{	Token t = getToken(0);
//  	System.err.println("Operator "+t.image+" at line "+t.beginLine+" col "+t.beginColumn+" was interpreted as Infix Operator.");
  }/*@bgen(jjtree)*/
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
            jjtreeCloseNodeScope(jjtn000);
          }
        }
/*@egen*/
}