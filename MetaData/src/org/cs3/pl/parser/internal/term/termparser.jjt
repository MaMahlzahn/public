/**
* Example of JJTree file
*/

options {
  STATIC=false;
  NODE_USES_PARSER=true;
  NODE_PACKAGE="org.cs3.pl.parser.internal.term";
  NODE_PREFIX="AST";
  VISITOR=true;
  MULTI=true;
  DEBUG_PARSER=false;
  DEBUG_LOOKAHEAD=false;
  DEBUG_TOKEN_MANAGER=false;
  OPTIMIZE_TOKEN_MANAGER=true;
  NODE_SCOPE_HOOK=true;
  LOOKAHEAD=1;
  COMMON_TOKEN_ACTION=true;
}

PARSER_BEGIN(PrologTermParser)
package org.cs3.pl.parser.internal.term;
import java.io.InputStream;
import java.io.FileInputStream;
import java.io.File;
import java.io.FileNotFoundException;
import java.util.List;
import java.util.ArrayList;

class PrologTermParser {
	public OPS ops = new OPS();
	
	boolean test(Token t1, Token t2) {
		return t1.beginOffset == t2.endOffset;
//		System.err.println("begin: "+t1.image +","+ t1.beginOffset + ", end: "+ t2.endOffset);
//		return true;
	}
	
	void jjtreeOpenNodeScope(Node n)
    {
    	Token t = getToken(1);
    	//System.err.prinln("open node of type "+n);
    	//System.err.prinln("   first token: "+t.image+" at line "+t.beginLine+", column "+t.beginColumn+".");
      ((SimpleNode)n).setFirstToken(t);
      
    }

    void jjtreeCloseNodeScope(Node n)
    {
      Token t = getToken(0);
    	//System.err.prinln("closing node of type "+n);
    	//System.err.prinln("   last token: "+t.image+" at line "+t.beginLine+", column "+t.beginColumn+".");      
      ((SimpleNode)n).setLastToken(t);
      
      
	  
	  	//need to "manualy" figure out the start token, as node scope hooks are
		//called "to late" for nodes like ASTInfixTerm 
		//if the nodes children have already been poped, this should work:
		SimpleNode s = (SimpleNode)n;
		if(s.jjtGetNumChildren()>0){
			 SimpleNode firstChild = (SimpleNode)s.jjtGetChild(0);
			 s.setFirstToken(firstChild.getFirstToken());
		}
		//System.err.println("created: "+ s+" : "+s.getImage());
		
		
		if(n instanceof ASTInfixTerm){
		 ((ASTInfixTerm)n).flatten();
 	  
	  }
    }
	private List errors = new ArrayList();
	
	public List getErrors() {
		return errors;
	}
	public void error_skipto(int kind) {
	  ParseException e = generateParseException();  
	  errors.add(e);
	  Token t;
	  do {
	    t = getNextToken();
	  } while (t.kind != kind && t.kind != EOF);
	}
	public ASTCompilationUnit getASTRoot(){
		return (ASTCompilationUnit) jjtree.rootNode();
  	}
  public static void main(String args[]) throws FileNotFoundException {
	InputStream stream = null;
  	if(args==null||args.length==0){	
	    //System.err.println("Reading from standard input...");
	    stream=System.in;
  	}
  	else{
  		stream=PrologTermParser.class.getResourceAsStream(args[0]);
  	}
    PrologTermParser t = new PrologTermParser(stream);
    try {
      SimpleNode n = t.CompilationUnit();
      n.dump("");
      System.err.println("Thank you.");
    } catch (Exception e) {
      System.err.println("Oops.");
      System.err.println(e.getMessage());
      e.printStackTrace();
    }
  }
  
}

PARSER_END(PrologTermParser)
TOKEN_MGR_DECLS:{
void CommonTokenAction(Token t){
	 t.beginOffset = input_stream.getBeginOffset();
 	 t.endOffset = input_stream.getEndOffset();
}
}
SKIP :
{
<WHITESPACE: [" ", "\t","\n","\r"]>
}


/* COMMENTS */

MORE :
{
  "/*" : IN_MULTI_LINE_COMMENT
}


SPECIAL_TOKEN : {

    < SINGLE_LINE_COMMENT: "%"(~["\n","\r"])* ("\n"|"\r"|"\r\n")? > }


<IN_MULTI_LINE_COMMENT>
SPECIAL_TOKEN :
{
  <MULTI_LINE_COMMENT: "*/" > : DEFAULT
}

<IN_SINGLE_LINE_COMMENT,IN_MULTI_LINE_COMMENT>
MORE :
{
  < ~[] >
}
TOKEN :
{
  <OPERATOR: (<OPBODY>|("'" <OPBODY> "'") ) >
  |<#OPBODY:
		("xor"
		|"@"
		|"^"
		|"-"
		|"-"
		|"mod"
		|"meta_predicate"
		|"discontiguous"
		|"thread_local"
		|"//"
		|"?"
		|"?"
		|"/"
		|"*"
		|">>"
		|"|"
		|"->"
		|"<"
		|"/\\"
		|">"
		|"\\+"
		|"\\=="
		|">="
		|"rem"
		|"*->"
		|"=<"
		|"**"
		|"+"
		|"+"
		|":="
		|"\\="
		|"\\"
		|":"
		|"=.."
		|"dynamic"
		|","
		|"=="
		|"$"
		|"=:="
		|"initialization"
		|"<<"
		|"=\\="
		|"@>="
		|"\\=@="
		|"-->"
		|"?-"
		|"@<"
		|"multifile"
		|"@=<"
		|":-"
		|":-"
		|"is"
		|"volatile"
		|"\\/"
		|"="
		|";"
		|"module_transparent"
		|"=@="
		|"@>")
		>
|
  < DECIMAL_LITERAL: ("0'" ~[])|(["0"-"9"] (["0"-"9"])*) >
|
  < BIN_LITERAL: ["0"-"9"] "b" ["0"-"1"] (["0"-"1"])* >
|
  < OCT_LITERAL: ["0"-"9"] "o" ["0"-"7"] (["0"-"7"])* >
|
  < HEX_LITERAL: ["0"-"9"] "x" ["0"-"9","A"-"F","a"-"f"] (["0"-"9","A"-"F","a"-"f"])* >
|
  < FLOATING_POINT_LITERAL:
        (["0"-"9"])+ "." (["0"-"9"])+ (<EXPONENT>)? /*(["f","F","d","D"])?*/
//      | "." (["0"-"9"])+ (<EXPONENT>)? /*(["f","F","d","D"])?*/
      | (["0"-"9"])+ <EXPONENT> /*(["f","F","d","D"])?*/
      | (["0"-"9"])+ (<EXPONENT>)? /*["f","F","d","D"]*/
  >
|
  < #EXPONENT: ["e","E"] (["+","-"])? (["0"-"9"])+ >
 | < CHARACTER_ATOM:
      "'"
      (   (~["\'","\\","\n","\r"])
        | ("\\"
            ( ["n","t","b","r","f","\\","'","\""]
            )
          )
        | ("''")
      )*
      "'" 
  >

|
  < STRING_LITERAL:
      "\""
      (   (~["\"","\\"]) /*,"\n","\r"*/
        | ("\\"
            ( ["n","t","b","r","f","\\","'","\""]
            | ["0"-"7"] ( ["0"-"7"] )?
            | ["0"-"3"] ["0"-"7"] ["0"-"7"]
            )
          )
        | ("\"\"")
      )*
      "\""
  >
  //|
    //< ZERO_APO_REST: "0'" ~["'"] >
  
}
/* IDENTIFIERS */

TOKEN :
{
  < VARIABLE: (<UNDERLINE> | <UPPERLETTER>) (<DIGIT>|<UPPERLETTER>|<LOWERLETTER>|<UNDERLINE>)* >
| 
  < IDENTIFIER: (<LOWERLETTER>|<DOLLAR>)(<DIGIT>|<UPPERLETTER>|<LOWERLETTER>|<VARIABLE>)* >

|
  < #UNDERLINE:
      [
       "_"
      ]
  >
|

  < #UPPERLETTER:
      [
       "A"-"Z"
      ]
  >
|
  < #DIGIT:
      [
       "0"-"9"
      ]
  >
|
  < #LOWERLETTER:
      [
       "a"-"z"
      ]
  >
 |

  < DOLLAR  :"$">
 |
  < CUT :"!">
  |
  < DOT :".">


}


SimpleNode CompilationUnit() : {}
{
  (
  try{
  	Member() 
  } catch (ParseException e) {
  		e.printStackTrace();
	    error_skipto(DOT);
	    //pop nodes from the stack down to the last
	    //successfully parsed term
		ops.clear();
		while(jjtree.nodeArity()>0 &&!(jjtree.peekNode() instanceof ASTMember)){
			
			//System.err.println("popped: "+jjtree.popNode());
		}
//		System.err.println("next i will read: "+getToken(1));
  }
  )*
  <EOF>
  { return jjtThis; }
  
}

void Member():{}
{
	Term() <DOT>
}
void Term() #void: 
{String opImage;}
{

	PrefixBoundTerm()
	(
		LOOKAHEAD({
			ops.isValidRHInfixOp(getToken(1).image,(SimpleNode)jjtree.peekNode())
		})
		InfixOperator()
		{ 
			opImage=getToken(0).image;
			ops.pushInfixOp(opImage);
		} 
		Term()
		{
			ops.popOp();
		}#InfixTerm(3)
	)* 
	
}




void PrefixBoundTerm() #void:{}
{
	(		
		LOOKAHEAD(CompoundTerm(),{
					test(getToken(2),getToken(1)) &&
		!",".equals(getToken(1).image)}) CompoundTerm()
		|
			LOOKAHEAD(<OPERATOR> PrefixBoundTerm(),{
				ops.isValidRHPrefixOp(getToken(1).image)
				&&  ( ops.isPrefixOp(getToken(2).image)
						&&  ops.lookupPrefixRHBound(getToken(1).image)
						    >=ops.lookupPrefixPrec(getToken(2).image)
					||ops.isInfixOp(getToken(2).image)
						&&	ops.lookupInfixLHBound(getToken(2).image)
							<ops.lookupPrefixPrec(getToken(1).image)				
					|| !ops.isInfixOp(getToken(2).image)
						&& ! ops.isPrefixOp(getToken(2).image)							
					) 
			})
			PrefixOperator()
			{				
				ops.pushPrefixOp(getToken(0).image);
			}
			Term()
			{
				ops.popOp();
			}
			#PrefixTerm(2)
		

		|ParanthesisTerm()
		|BracesTerm()
		|ListTerm()
		|Atom()
		|Number()
		|String()
		|Variable()
	)
	
}

void BracesTerm() :
{}
{
	"{" 
	{ops.pushReset();}
	Term() 
	{ops.popOp();}
	"}"
}

void ListTerm() :
{}
{
	"[" 
	{ops.pushReset();}
	(Term())?
	{ops.popOp();}
	"]"
}

void ParanthesisTerm() :
{}
{
	"(" 
	{ops.pushReset();}
	Term() 
	{ops.popOp();}
	")"
}
void CompoundTerm() :
{}
{
	Atom()
	"("
	{ops.pushReset();}
	Term() 
	{ops.popOp();}
	")"
}


void Atom() #void: {}
{
	Cut()| Identifier()|Characters()
	
}
void Cut() :{}
{
	<CUT>
}
void Number() #void:{}
{
	Integer()|Float()
}
void String() :{}
{
	<STRING_LITERAL>
}

void Variable() :{}
{
	<VARIABLE>
}


void Identifier() : {}
{	
	<OPERATOR>
	|  <IDENTIFIER>
	|<DOT>
  
}

void Integer() : {}
{
  <DECIMAL_LITERAL>|<BIN_LITERAL>|<OCT_LITERAL>|<HEX_LITERAL>
}

void Float() :{}
{
	<FLOATING_POINT_LITERAL>
}

void Characters() :{}
{
	<CHARACTER_ATOM>
}


void PrefixOperator() :{}
{
	<OPERATOR>
	{	Token t = getToken(0);
//  	System.err.println("Operator "+t.image+" at line "+t.beginLine+" col "+t.beginColumn+" was interpreted as Prefix Operator.");
  }
}


void InfixOperator() :{}
{
	<OPERATOR>
	{	Token t = getToken(0);
//  	System.err.println("Operator "+t.image+" at line "+t.beginLine+" col "+t.beginColumn+" was interpreted as Infix Operator.");
  }
}