<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<!--NewPage-->
<HTML>
<HEAD>
<!-- Generated by javadoc (build 1.4.2_07) on Wed Sep 13 21:26:07 CEST 2006 -->
<TITLE>
AsyncPrologSession
</TITLE>

<META NAME="keywords" CONTENT="org.cs3.pl.prolog.AsyncPrologSession interface">

<LINK REL ="stylesheet" TYPE="text/css" HREF="../../../../stylesheet.css" TITLE="Style">

<SCRIPT type="text/javascript">
function windowTitle()
{
    parent.document.title="AsyncPrologSession";
}
</SCRIPT>

</HEAD>

<BODY BGCOLOR="white" onload="windowTitle();">


<!-- ========= START OF TOP NAVBAR ======= -->
<A NAME="navbar_top"><!-- --></A>
<A HREF="#skip-navbar_top" title="Skip navigation links"></A>
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=3 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_top_firstrow"><!-- --></A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../overview-summary.html"><FONT CLASS="NavBarFont1"><B>Overview</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><B>Package</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>Class</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="class-use/AsyncPrologSession.html"><FONT CLASS="NavBarFont1"><B>Use</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>Tree</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>Deprecated</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../index-files/index-1.html"><FONT CLASS="NavBarFont1"><B>Index</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../help-doc.html"><FONT CLASS="NavBarFont1"><B>Help</B></FONT></A>&nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
</EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;PREV CLASS&nbsp;
&nbsp;<A HREF="../../../../org/cs3/pl/prolog/AsyncPrologSessionListener.html" title="interface in org.cs3.pl.prolog"><B>NEXT CLASS</B></A></FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../../../../index.html" target="_top"><B>FRAMES</B></A>  &nbsp;
&nbsp;<A HREF="AsyncPrologSession.html" target="_top"><B>NO FRAMES</B></A>  &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../../../allclasses-noframe.html"><B>All Classes</B></A>');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../../../../allclasses-noframe.html"><B>All Classes</B></A>
</NOSCRIPT>

</FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  SUMMARY:&nbsp;NESTED&nbsp;|&nbsp;FIELD&nbsp;|&nbsp;CONSTR&nbsp;|&nbsp;<A HREF="#method_summary">METHOD</A></FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
DETAIL:&nbsp;FIELD&nbsp;|&nbsp;CONSTR&nbsp;|&nbsp;<A HREF="#method_detail">METHOD</A></FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_top"></A>
<!-- ========= END OF TOP NAVBAR ========= -->

<HR>
<!-- ======== START OF CLASS DATA ======== -->
<H2>
<FONT SIZE="-1">
org.cs3.pl.prolog</FONT>
<BR>
Interface AsyncPrologSession</H2>
<DL>
<DT><B>All Superinterfaces:</B> <DD><A HREF="../../../../org/cs3/pl/prolog/Disposable.html" title="interface in org.cs3.pl.prolog">Disposable</A>, org.cs3.pl.common.OptionProvider</DD>
</DL>
<HR>
<DL>
<DT>public interface <B>AsyncPrologSession</B><DT>extends org.cs3.pl.common.OptionProvider, <A HREF="../../../../org/cs3/pl/prolog/Disposable.html" title="interface in org.cs3.pl.prolog">Disposable</A></DL>

<P>
Prolog Session for asynchronous queries.
 
 An AsyncPrologSession is actually a batch processor. As with the normal
 PrologSession, a single prolog engine thread is attached to it through its
 complete lifetime. This prolog engine thread is called "the processor" in the
 remainder of this document.
 
 The batch can be thought of as a FIFO queue. Clients add queries to the queue
 using the queryAll(Object,String) and queryOnce(Object,String) methods. But
 unlike the PrologSession, the AsyncPrologSession will not wait for any reply
 from the processor, but will return control to the calling thread imediatly.
 Clients can obtain the results of the queries by registering a
 AsyncPrologSessionListener. The processor will write all results back into
 the output queue. On the client side, a dedicated dispatcher thread reads and
 parses the incoming results an will dispatch them to the registered
 listeners.
<P>

<P>
<DL>
<DT><B>Author:</B></DT>
  <DD>lukas</DD>
</DL>
<HR>

<P>
<!-- ======== NESTED CLASS SUMMARY ======== -->


<!-- =========== FIELD SUMMARY =========== -->


<!-- ======== CONSTRUCTOR SUMMARY ======== -->


<!-- ========== METHOD SUMMARY =========== -->

<A NAME="method_summary"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TD COLSPAN=2><FONT SIZE="+2">
<B>Method Summary</B></FONT></TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../org/cs3/pl/prolog/AsyncPrologSession.html#abort()">abort</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Abort the batch.
 
 </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../org/cs3/pl/prolog/AsyncPrologSession.html#abort(java.lang.Object)">abort</A></B>(java.lang.Object&nbsp;monitor)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Abort the batch, using a sepcific monitor as ticket.
 
 </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../org/cs3/pl/prolog/AsyncPrologSession.html#addBatchListener(org.cs3.pl.prolog.AsyncPrologSessionListener)">addBatchListener</A></B>(<A HREF="../../../../org/cs3/pl/prolog/AsyncPrologSessionListener.html" title="interface in org.cs3.pl.prolog">AsyncPrologSessionListener</A>&nbsp;l)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../org/cs3/pl/prolog/AsyncPrologSession.html#dispose()">dispose</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Dispose the batch.
 
 </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.lang.Object</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../org/cs3/pl/prolog/AsyncPrologSession.html#getLastAbortTicket()">getLastAbortTicket</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;get the ticket used for the last abort request.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;java.lang.String</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../org/cs3/pl/prolog/AsyncPrologSession.html#getProcessorThreadAlias()">getProcessorThreadAlias</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;retrieve the thread alias of the processor.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../org/cs3/pl/prolog/AsyncPrologSession.html#isDisposed()">isDisposed</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Check if the batch is disposed.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../org/cs3/pl/prolog/AsyncPrologSession.html#isIdle()">isIdle</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../org/cs3/pl/prolog/AsyncPrologSession.html#isPending(java.lang.Object)">isPending</A></B>(java.lang.Object&nbsp;ticket)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;check wether a request is on queue.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../org/cs3/pl/prolog/AsyncPrologSession.html#join()">join</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Wait for pending queries.
 
 </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../org/cs3/pl/prolog/AsyncPrologSession.html#queryAll(java.lang.Object, java.lang.String)">queryAll</A></B>(java.lang.Object&nbsp;ticket,
         java.lang.String&nbsp;query)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Enqueue a request for all solutions to a goal.
 
 </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../org/cs3/pl/prolog/AsyncPrologSession.html#queryOnce(java.lang.Object, java.lang.String)">queryOnce</A></B>(java.lang.Object&nbsp;ticket,
          java.lang.String&nbsp;query)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Enque a request for the first solution to a goal.
 
 </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../../org/cs3/pl/prolog/AsyncPrologSession.html#removeBatchListener(org.cs3.pl.prolog.AsyncPrologSessionListener)">removeBatchListener</A></B>(<A HREF="../../../../org/cs3/pl/prolog/AsyncPrologSessionListener.html" title="interface in org.cs3.pl.prolog">AsyncPrologSessionListener</A>&nbsp;l)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
</TABLE>
&nbsp;<A NAME="methods_inherited_from_class_org.cs3.pl.common.OptionProvider"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#EEEEFF" CLASS="TableSubHeadingColor">
<TD><B>Methods inherited from interface org.cs3.pl.common.OptionProvider</B></TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE>getOptions, getPreferenceValue, reconfigure, setPreferenceValue</CODE></TD>
</TR>
</TABLE>
&nbsp;
<P>

<!-- ============ FIELD DETAIL =========== -->


<!-- ========= CONSTRUCTOR DETAIL ======== -->


<!-- ============ METHOD DETAIL ========== -->

<A NAME="method_detail"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TD COLSPAN=1><FONT SIZE="+2">
<B>Method Detail</B></FONT></TD>
</TR>
</TABLE>

<A NAME="addBatchListener(org.cs3.pl.prolog.AsyncPrologSessionListener)"><!-- --></A><H3>
addBatchListener</H3>
<PRE>
public void <B>addBatchListener</B>(<A HREF="../../../../org/cs3/pl/prolog/AsyncPrologSessionListener.html" title="interface in org.cs3.pl.prolog">AsyncPrologSessionListener</A>&nbsp;l)</PRE>
<DL>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="removeBatchListener(org.cs3.pl.prolog.AsyncPrologSessionListener)"><!-- --></A><H3>
removeBatchListener</H3>
<PRE>
public void <B>removeBatchListener</B>(<A HREF="../../../../org/cs3/pl/prolog/AsyncPrologSessionListener.html" title="interface in org.cs3.pl.prolog">AsyncPrologSessionListener</A>&nbsp;l)</PRE>
<DL>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<HR>

<A NAME="queryAll(java.lang.Object, java.lang.String)"><!-- --></A><H3>
queryAll</H3>
<PRE>
public void <B>queryAll</B>(java.lang.Object&nbsp;ticket,
                     java.lang.String&nbsp;query)
              throws <A HREF="../../../../org/cs3/pl/prolog/PrologInterfaceException.html" title="class in org.cs3.pl.prolog">PrologInterfaceException</A></PRE>
<DL>
<DD>Enqueue a request for all solutions to a goal.
 
 Results, errors, etc will be reported asynchronously to registered
 listeners.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>ticket</CODE> - An arbitrary object that will be reported back together with
            the results. clients can use this to identify results to a
            certain query or group of queries.<DD><CODE>query</CODE> - the query goal
<DT><B>Throws:</B>
<DD><CODE><A HREF="../../../../org/cs3/pl/prolog/PrologInterfaceException.html" title="class in org.cs3.pl.prolog">PrologInterfaceException</A></CODE><DT><B>See Also:</B><DD><A HREF="../../../../org/cs3/pl/prolog/AsyncPrologSessionListener.html" title="interface in org.cs3.pl.prolog"><CODE>AsyncPrologSessionListener</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="queryOnce(java.lang.Object, java.lang.String)"><!-- --></A><H3>
queryOnce</H3>
<PRE>
public void <B>queryOnce</B>(java.lang.Object&nbsp;ticket,
                      java.lang.String&nbsp;query)
               throws <A HREF="../../../../org/cs3/pl/prolog/PrologInterfaceException.html" title="class in org.cs3.pl.prolog">PrologInterfaceException</A></PRE>
<DL>
<DD>Enque a request for the first solution to a goal.
 
 Results, errors, etc will be reported asynchronously to registered
 listeners.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>ticket</CODE> - An arbitrary object that will be reported back together with
            the results. clients can use this to identify results to a
            certain query or group of queries.<DD><CODE>query</CODE> - the query goal
<DT><B>Throws:</B>
<DD><CODE><A HREF="../../../../org/cs3/pl/prolog/PrologInterfaceException.html" title="class in org.cs3.pl.prolog">PrologInterfaceException</A></CODE><DT><B>See Also:</B><DD><A HREF="../../../../org/cs3/pl/prolog/AsyncPrologSessionListener.html" title="interface in org.cs3.pl.prolog"><CODE>AsyncPrologSessionListener</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="join()"><!-- --></A><H3>
join</H3>
<PRE>
public void <B>join</B>()
          throws <A HREF="../../../../org/cs3/pl/prolog/PrologInterfaceException.html" title="class in org.cs3.pl.prolog">PrologInterfaceException</A></PRE>
<DL>
<DD>Wait for pending queries.
 
 Blocks the calling thread until all currently pending queries have been
 processed. Conceptually, this works like an alarm clock: the calling
 thread puts a marker on the queue and then goes to sleep. When the
 processor encounters the marker it will send it back to the dispatcher,
 which will wake up the sleeping thread. You can use this, if your client
 needs (partial) results from the enqueued queries before it can go on.
 Other threads may continue adding queries after the mark while this
 thread is waiting. Also note that another thread may abort the batch -
 the marker will be processed nevertheless.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>Throws:</B>
<DD><CODE><A HREF="../../../../org/cs3/pl/prolog/PrologInterfaceException.html" title="class in org.cs3.pl.prolog">PrologInterfaceException</A></CODE></DL>
</DD>
</DL>
<HR>

<A NAME="abort()"><!-- --></A><H3>
abort</H3>
<PRE>
public void <B>abort</B>()
           throws <A HREF="../../../../org/cs3/pl/prolog/PrologInterfaceException.html" title="class in org.cs3.pl.prolog">PrologInterfaceException</A></PRE>
<DL>
<DD>Abort the batch.
 
 Adds a special abort marker to the queue and sends an abort message to
 the processor's message queue. The processor will cut the current query
 at the earliest possible time and will then skip all enqueued queries
 until it reaches the abort marker. (other markers will be processed
 normally) During the whole process, the batch is operational and can be
 used as always. Note that abort can be used to break out of endless
 loops, e.g. by cutting a a repeat/0. It does however not help in waking
 up blocking system calls, etc. Those have to be dealt with in an
 application-specific manner.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>Throws:</B>
<DD><CODE><A HREF="../../../../org/cs3/pl/prolog/PrologInterfaceException.html" title="class in org.cs3.pl.prolog">PrologInterfaceException</A></CODE></DL>
</DD>
</DL>
<HR>

<A NAME="abort(java.lang.Object)"><!-- --></A><H3>
abort</H3>
<PRE>
public void <B>abort</B>(java.lang.Object&nbsp;monitor)
           throws <A HREF="../../../../org/cs3/pl/prolog/PrologInterfaceException.html" title="class in org.cs3.pl.prolog">PrologInterfaceException</A></PRE>
<DL>
<DD>Abort the batch, using a sepcific monitor as ticket.
 
 Like abort(), but allows the caller to choose the ticket that is used
 with the abort marker. The session uses this ticket as monitor when
 waiting for the marker echo. The idea is to allow something like this:
 <code> 
 final Object lock = new Object();
 session.queryOnce("some_blocking_predicate");
 synchronized (lock) {
   Thread thread = new Thread() {
      public void run() {
         synchronized (lock) {
            //some code to wake up the processor
 	          //It needs to be called AFTER the abort marker was written
	          //and after the abort message was send.
	       }
	    }
   };
   thread.start();
   session.abort(lock);
 }
 </code>
 
 This method is mainly usefull for test cases, where it is important that
 things happen in a certain order. You should overuse it in your
 application.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>Throws:</B>
<DD><CODE><A HREF="../../../../org/cs3/pl/prolog/PrologInterfaceException.html" title="class in org.cs3.pl.prolog">PrologInterfaceException</A></CODE></DL>
</DD>
</DL>
<HR>

<A NAME="getLastAbortTicket()"><!-- --></A><H3>
getLastAbortTicket</H3>
<PRE>
public java.lang.Object <B>getLastAbortTicket</B>()</PRE>
<DL>
<DD>get the ticket used for the last abort request.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>the ticket or null if there are no pending aborts.</DL>
</DD>
</DL>
<HR>

<A NAME="isPending(java.lang.Object)"><!-- --></A><H3>
isPending</H3>
<PRE>
public boolean <B>isPending</B>(java.lang.Object&nbsp;ticket)</PRE>
<DL>
<DD>check wether a request is on queue.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>ticket</CODE> - the ticket used with the request.
<DT><B>Returns:</B><DD>true if at least one request was enqueued using this ticket,
 and this request has not yet been processed.</DL>
</DD>
</DL>
<HR>

<A NAME="isIdle()"><!-- --></A><H3>
isIdle</H3>
<PRE>
public boolean <B>isIdle</B>()</PRE>
<DL>
<DD><DL>
</DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>true if there are no pending requests.</DL>
</DD>
</DL>
<HR>

<A NAME="dispose()"><!-- --></A><H3>
dispose</H3>
<PRE>
public void <B>dispose</B>()</PRE>
<DL>
<DD>Dispose the batch.
 
 Adds a special end_of_batch marker to the queue. No more queries may
 follow this marker. The processor will continue to process all encqueued
 queries and markers until it reaches the end_of_batch marker. It will
 then notify the listeners, shut down the dispatcher and close the batch.
 
 While the batch is disposing, it is still possible to call join() and
 abort(), Once the batch has been closed, this calls will have no effect.
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE><A HREF="../../../../org/cs3/pl/prolog/Disposable.html#dispose()">dispose</A></CODE> in interface <CODE><A HREF="../../../../org/cs3/pl/prolog/Disposable.html" title="interface in org.cs3.pl.prolog">Disposable</A></CODE></DL>
</DD>
<DD><DL>

<DT><B>Throws:</B>
<DD><CODE><A HREF="../../../../org/cs3/pl/prolog/PrologInterfaceException.html" title="class in org.cs3.pl.prolog">PrologInterfaceException</A></CODE></DL>
</DD>
</DL>
<HR>

<A NAME="isDisposed()"><!-- --></A><H3>
isDisposed</H3>
<PRE>
public boolean <B>isDisposed</B>()</PRE>
<DL>
<DD>Check if the batch is disposed.
<P>
<DD><DL>
<DT><B>Specified by:</B><DD><CODE><A HREF="../../../../org/cs3/pl/prolog/Disposable.html#isDisposed()">isDisposed</A></CODE> in interface <CODE><A HREF="../../../../org/cs3/pl/prolog/Disposable.html" title="interface in org.cs3.pl.prolog">Disposable</A></CODE></DL>
</DD>
<DD><DL>

<DT><B>Returns:</B><DD>true if the batch is disposed or in the proceess of beeing
         disposed.<DT><B>See Also:</B><DD><A HREF="../../../../org/cs3/pl/prolog/AsyncPrologSession.html#dispose()"><CODE>dispose()</CODE></A></DL>
</DD>
</DL>
<HR>

<A NAME="getProcessorThreadAlias()"><!-- --></A><H3>
getProcessorThreadAlias</H3>
<PRE>
public java.lang.String <B>getProcessorThreadAlias</B>()</PRE>
<DL>
<DD>retrieve the thread alias of the processor.
<P>
<DD><DL>
</DL>
</DD>
<DD><DL>
</DL>
</DD>
</DL>
<!-- ========= END OF CLASS DATA ========= -->
<HR>


<!-- ======= START OF BOTTOM NAVBAR ====== -->
<A NAME="navbar_bottom"><!-- --></A>
<A HREF="#skip-navbar_bottom" title="Skip navigation links"></A>
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=3 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_bottom_firstrow"><!-- --></A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../overview-summary.html"><FONT CLASS="NavBarFont1"><B>Overview</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><B>Package</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>Class</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="class-use/AsyncPrologSession.html"><FONT CLASS="NavBarFont1"><B>Use</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>Tree</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>Deprecated</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../index-files/index-1.html"><FONT CLASS="NavBarFont1"><B>Index</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../../help-doc.html"><FONT CLASS="NavBarFont1"><B>Help</B></FONT></A>&nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
</EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;PREV CLASS&nbsp;
&nbsp;<A HREF="../../../../org/cs3/pl/prolog/AsyncPrologSessionListener.html" title="interface in org.cs3.pl.prolog"><B>NEXT CLASS</B></A></FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../../../../index.html" target="_top"><B>FRAMES</B></A>  &nbsp;
&nbsp;<A HREF="AsyncPrologSession.html" target="_top"><B>NO FRAMES</B></A>  &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../../../allclasses-noframe.html"><B>All Classes</B></A>');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../../../../allclasses-noframe.html"><B>All Classes</B></A>
</NOSCRIPT>

</FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  SUMMARY:&nbsp;NESTED&nbsp;|&nbsp;FIELD&nbsp;|&nbsp;CONSTR&nbsp;|&nbsp;<A HREF="#method_summary">METHOD</A></FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
DETAIL:&nbsp;FIELD&nbsp;|&nbsp;CONSTR&nbsp;|&nbsp;<A HREF="#method_detail">METHOD</A></FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_bottom"></A>
<!-- ======== END OF BOTTOM NAVBAR ======= -->

<HR>

</BODY>
</HTML>
