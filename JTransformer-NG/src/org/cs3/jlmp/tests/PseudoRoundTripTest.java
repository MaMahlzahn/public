package org.cs3.jlmp.tests;

import java.io.BufferedReader;
import java.io.File;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.Iterator;
import java.util.List;
import java.util.Map;

import junit.framework.Test;
import junit.framework.TestSuite;

import org.cs3.jlmp.JLMP;
import org.cs3.jlmp.JLMPPlugin;
import org.cs3.jlmp.natures.JLMPProjectNature;
import org.cs3.pl.common.ResourceFileLocator;
import org.cs3.pl.common.Util;
import org.cs3.pl.prolog.PrologInterface;
import org.cs3.pl.prolog.PrologSession;
import org.eclipse.core.resources.IFile;
import org.eclipse.core.resources.IFolder;
import org.eclipse.core.resources.IProject;
import org.eclipse.core.resources.IResource;
import org.eclipse.core.resources.IResourceVisitor;
import org.eclipse.core.resources.ResourcesPlugin;
import org.eclipse.core.runtime.CoreException;
import org.eclipse.core.runtime.Path;
import org.eclipse.jdt.core.ICompilationUnit;
import org.eclipse.jdt.core.IJavaProject;
import org.eclipse.jdt.core.JavaCore;
import org.eclipse.jface.text.BadLocationException;

/**
 * Testing for bytecode invariance of fact generation / source re-generation
 * roundtripp.
 * 
 * 
 * <p>
 * This testcase will
 * <ul>
 * <li>setup the converter testproject</li>
 * <li>traverse all packeges starting with "test"</li>
 * <li>for each package
 * <ul>
 * <li>create prolog facts for all files in this package.</li>
 * <li>consult the generated facts</li>
 * <li>normalize all source files in that package</li>
 * <li>compile all files in the package</li>
 * <li>rename the resulting class files by attaching the prefix ".orig" This
 * set of files is until now adressed as "the original bytecode"</li>
 * <li>rename the normalized source files by attaching the prefix ".orig" Those
 * files will be adressed as "the original source code"</li>
 * <li>regenerate the source code of all toplevels present in the prolog system
 * </li>
 * <li>normalize the resulting source files in the package. These files will
 * from now on be called "the generated sourcecode"</li>
 * <li>Assert that for each original source file there is a generated source
 * file with corresponding name.</li>
 * <li>Assert that for each generated source file there is an original source
 * file with corresponding name.</li>
 * <li>compile all files in the package, from now on adressed as "the generated
 * bytecode"</li>
 * <li>assert that for each original bytecode file there is a generated
 * bytecode file with corresponding name.</li>
 * <li>assert that for each generated bytecode file there is an original
 * bytecode file with corresponding name.</li>
 * <li>assert that each corresponding pair of original and generated bytecode
 * files is binary identical.</li>
 * </ul>
 * </li>
 * </ul>
 *  
 */
public class PseudoRoundTripTest extends FactGenerationTest {

    private String packageName;
	private PrologSession session;
    
    /**
     * @param name
     */
    public PseudoRoundTripTest(String name) {
        super(name);
        this.packageName = name;
    }

    /**
     * @param string
     * @param string2
     */
    public PseudoRoundTripTest(String name, String packageName) {
        super(name);
        
        this.packageName = packageName;
    }

    protected Object getKey() {

        return PseudoRoundTripTest.class;
    }

    public void setUpOnce() {
        super.setUpOnce();
        //install test workspace
        ResourceFileLocator l = JLMPPlugin.getDefault().getResourceLocator("");
        File r = l.resolve("testdata-roundtrip.zip");
        Util.unzip(r);
        org.cs3.pl.common.Debug.info("setUpOnce caled for key  " + getKey());
        setAutoBuilding(false);
        PrologInterface pif = getTestJLMPProject().getPrologInterface();
        try {
            pif.start();
        } catch (IOException e) {
            throw new RuntimeException(e);
        }
       
    }

    public void testIt() throws CoreException, IOException,
            BadLocationException {
       
        Util.startTime("untilBuild");
        IProject project = getTestProject();
        IJavaProject javaProject = getTestJavaProject();
        JLMPProjectNature jlmpProject = getTestJLMPProject();
        PrologInterface pif = jlmpProject.getPrologInterface();
        
		org.cs3.pl.common.Debug.info("Running (Pseudo)roundtrip in " + packageName);
        //retrieve all cus in package
        ICompilationUnit[] cus = getCompilationUnitsInFolder( packageName);
        //normalize source files
        Util.startTime("norm1");
        for (int i = 0; i < cus.length; i++) {
            ICompilationUnit cu = cus[i];
            normalizeCompilationUnit(cu);

        }
        Util.printTime("norm1");
        Util.printTime("untilBuild");
        Util.startTime("build1");
        build(JavaCore.BUILDER_ID);
        build(JLMP.BUILDER_ID);
        Util.printTime("build1");
        Util.startTime("untilQueryToplevels");
        //now we should have SOME toplevelT
        assertNotNull("no toplevelT????", session.queryOnce("toplevelT(_,_,_,_)"));
        
        //and checkTreeLinks should say "yes"
        //assertNotNull("checkTreeLinks reports errors", session.queryOnce("checkTreeLinks"));      
        


        IResourceVisitor renamer = new IResourceVisitor() {
            public boolean visit(IResource resource) throws CoreException {
                switch (resource.getType()) {
                case IResource.FOLDER:
                    return true;
                case IResource.FILE:
                    IFile file = (IFile) resource;
                    file.move(file.getFullPath().addFileExtension("orig"),
                            true, null);
                    break;
                case IResource.PROJECT:
                    return true;
                default:
                    throw new IllegalStateException("Unexpected resource type.");                    
                }
                return false;
            }
        };
        Util.startTime("rename");
        IFolder folder = project.getFolder(packageName);        
        folder.accept(renamer);
        Util.printTime("rename");
              
        //next, we use gen_tree on each toplevelT node known to the system.
        //as a result we should be able to regenerate each and every source
        // file we consulted
        //in the first step
        String query = "toplevelT(ID,_,FILENAME,_),gen_tree(ID,CONTENT)";
        Util.printTime("untilQueryToplevels");
        Util.startTime("queryToplevels");
        List results = session.queryAll(query);
        Util.printTime("queryToplevels");
        Util.startTime("writeToplevels");
        for (Iterator iter = results.iterator(); iter.hasNext();) {
            Map result = (Map) iter.next();
            String filename = result.get("FILENAME").toString();
            String content = result.get("CONTENT").toString();
            //clean the facts right away. another testcase might be running
            //concurrently and this is the easiest way to keep things from interfering
            session.queryOnce("remove_contained_global_ids('" + filename+ "')");
            session.queryOnce("delete_toplevel('" + filename + "')");              
            assertTrue("problems writing generated file.", createFile(filename,
                    content).isAccessible());            
            IFile file = ResourcesPlugin.getWorkspace().getRoot().getFile(new Path(filename));
            String newContent = Util.toString(file.getContents());
            assertEquals(content,newContent);
        }
        Util.printTime("writeToplevels");
        //refetch cus
      Util.startTime("norm2");
        cus = getCompilationUnitsInFolder(packageName);
        //normalize again (now the generated source)
        for (int i = 0; i < cus.length; i++) {
            ICompilationUnit cu = cus[i];
            normalizeCompilationUnit(cu);

        }
        Util.printTime("norm2");
        //build again.(the generated source)
        Util.startTime("build2");
        
       build(JavaCore.BUILDER_ID);
       Util.printTime("build2");
        //now, visit each file in the binFolder, that has the .class extension.
        //and compare it to the respective original class file (which should
        // have the same name + .orig)
        IResourceVisitor comparator = new IResourceVisitor() {
            public boolean visit(IResource resource) throws CoreException {
                switch (resource.getType()) {
                case IResource.FOLDER:
                    return true;
                case IResource.FILE:
                    IFile file = (IFile) resource;
                	if(!file.getFileExtension().equals("class")) return false;
                	
                	IFile orig = ResourcesPlugin.getWorkspace().getRoot().getFile(file.getFullPath().addFileExtension("orig"));
                	assertTrue("original class file not accessible: "+orig.getFullPath().toString(),orig.isAccessible());
                	//both files should be of EXACTLY the same size:
                	BufferedReader origReader = new BufferedReader(new InputStreamReader(orig.getContents()));
                	BufferedReader genReader = new BufferedReader(new InputStreamReader(file.getContents()));
                	int origR=0;
                	int genR=0;
                	int i=0;
                	for( i=0;origR!=-1&&genR!=-1;i++){
                	    try {
                            origR= origReader.read();
                            genR= genReader.read();
                            assertTrue("orig and generated file differ at position "+i,origR==genR);
                        } catch (IOException e) {                        
                            org.cs3.pl.common.Debug.report(e);
                        }                	    
                	}
                	org.cs3.pl.common.Debug.info("compared "+i+" chars succsessfully.");
                    return false;

                }
                return false;
            }
        };
        Util.startTime("compare");
        folder.accept(comparator);
        Util.printTime("compare");
    }
    protected void setUp() throws Exception {     
        super.setUp(); 
        PrologInterface pif = getTestJLMPProject().getPrologInterface();        
        session=pif.getSession();
        setTestDataLocator(JLMPPlugin.getDefault().getResourceLocator("testdata-roundtrip"));
        
        install(packageName);
    }
    protected void tearDown() throws Exception {     
        super.tearDown();
        PrologInterface pif = getTestJLMPProject().getPrologInterface();        
        session.dispose();        
        uninstall(packageName);
    }
    public void tearDownOnce() {
        super.tearDownOnce();
        org.cs3.pl.common.Debug.info("tearDownOnce caled for key  " + getKey());
        PrologInterface pif = getTestJLMPProject().getPrologInterface();
        session.dispose();
        try {
            pif.stop();
        } catch (IOException e) {
            throw new RuntimeException(e);
        }
        
        
    }

    public static Test suite() {
        TestSuite s = new TestSuite();
        for (int i = 1; i <= 539; i++)
            s
                    .addTest(new PseudoRoundTripTest("testIt",
                            generatePackageName(i)));
        return s;
    }

    /**
     * @param i
     * @return
     */
    private static String generatePackageName(int n) {
        int desiredLength = 4;
        String number = String.valueOf(n);
        int padLength = desiredLength - number.length();
        StringBuffer sb = new StringBuffer("test");
        for (int i = 0; i < padLength; i++)
            sb.append('0');
        sb.append(number);
        return sb.toString();
    }

}