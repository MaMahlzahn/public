package org.cs3.jlmp.tests;

import java.io.BufferedReader;
import java.io.ByteArrayInputStream;
import java.io.ByteArrayOutputStream;
import java.io.File;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.PrintStream;
import java.util.Iterator;
import java.util.List;
import java.util.Map;

import junit.framework.Test;
import junit.framework.TestSuite;

import org.cs3.jlmp.JLMP;
import org.cs3.jlmp.JLMPPlugin;
import org.cs3.jlmp.natures.JLMPProjectNature;
import org.cs3.pl.common.ResourceFileLocator;
import org.cs3.pl.common.Util;
import org.cs3.pl.prolog.PrologInterface;
import org.cs3.pl.prolog.PrologSession;
import org.eclipse.core.resources.IFile;
import org.eclipse.core.resources.IFolder;
import org.eclipse.core.resources.IProject;
import org.eclipse.core.resources.IResource;
import org.eclipse.core.resources.IResourceVisitor;
import org.eclipse.core.resources.IncrementalProjectBuilder;
import org.eclipse.core.resources.ResourcesPlugin;
import org.eclipse.core.runtime.CoreException;
import org.eclipse.core.runtime.NullProgressMonitor;
import org.eclipse.core.runtime.Path;
import org.eclipse.jdt.core.ICompilationUnit;
import org.eclipse.jdt.core.IJavaProject;
import org.eclipse.jface.text.BadLocationException;

/**
 * Testing for bytecode invariance of fact generation / source re-generation
 * roundtripp.
 * 
 * 
 * <p>
 * This testcase will
 * <ul>
 * <li>setup the converter testproject</li>
 * <li>traverse all packeges starting with "test"</li>
 * <li>for each package
 * <ul>
 * <li>create prolog facts for all files in this package.</li>
 * <li>consult the generated facts</li>
 * <li>normalize all source files in that package</li>
 * <li>compile all files in the package</li>
 * <li>rename the resulting class files by attaching the prefix ".orig" This
 * set of files is until now adressed as "the original bytecode"</li>
 * <li>rename the normalized source files by attaching the prefix ".orig" Those
 * files will be adressed as "the original source code"</li>
 * <li>regenerate the source code of all toplevels present in the prolog system
 * </li>
 * <li>normalize the resulting source files in the package. These files will
 * from now on be called "the generated sourcecode"</li>
 * <li>Assert that for each original source file there is a generated source
 * file with corresponding name.</li>
 * <li>Assert that for each generated source file there is an original source
 * file with corresponding name.</li>
 * <li>compile all files in the package, from now on adressed as "the generated
 * bytecode"</li>
 * <li>assert that for each original bytecode file there is a generated
 * bytecode file with corresponding name.</li>
 * <li>assert that for each generated bytecode file there is an original
 * bytecode file with corresponding name.</li>
 * <li>assert that each corresponding pair of original and generated bytecode
 * files is binary identical.</li>
 * </ul>
 * </li>
 * </ul>
 *  
 */
public class PseudoRoundTripTest extends FactGenerationTest {

    private String packageName;
	private PrologSession session;
    
    /**
     * @param name
     */
    public PseudoRoundTripTest(String name) {
        super(name);
        this.packageName = name;
    }

    /**
     * @param string
     * @param string2
     */
    public PseudoRoundTripTest(String name, String packageName) {
        super(name);
        this.packageName = packageName;
    }

    protected Object getKey() {

        return PseudoRoundTripTest.class;
    }

    public void setUpOnce() {
        super.setUpOnce();
        //install test workspace
        ResourceFileLocator l = JLMPPlugin.getDefault().getResourceLocator("");
        File r = l.resolve("testdata-roundtrip.zip");
        Util.unzip(r);
        org.cs3.pl.common.Debug.info("setUpOnce caled for key  " + getKey());
        setAutoBuilding(false);
    }

    public void testIt() throws CoreException, IOException,
            BadLocationException {
        IProject project = getTestProject();
        IJavaProject javaProject = getTestJavaProject();
        JLMPProjectNature jlmpProject = getTestJLMPProject();
        PrologInterface pif = jlmpProject.getPrologInterface();
        
		org.cs3.pl.common.Debug.info("Running (Pseudo)roundtrip in " + packageName);
        //retrieve all cus in package
        ICompilationUnit[] cus = getCompilationUnits( packageName);
        //normalize source files
        for (int i = 0; i < cus.length; i++) {
            ICompilationUnit cu = cus[i];
            normalizeCompilationUnit(cu);

        }
        
        
        class _ProgressMonitor extends NullProgressMonitor{
            public Object lock=new Object();
            public boolean done = false;
            /* (non-Javadoc)
             * @see org.eclipse.core.runtime.NullProgressMonitor#done()
             */
            public void done() {                
                done=true;
                synchronized(lock){
                    lock.notifyAll();    
                }                
            }
            public void waitTillDone(){
                while(!done){
                    synchronized(lock){
                        try {
                            lock.wait();
                        } catch (InterruptedException e) {
                            throw new RuntimeException(e);
                        }
                    }
                }
            }
        };
        
        _ProgressMonitor m = new _ProgressMonitor();
        project.build(IncrementalProjectBuilder.INCREMENTAL_BUILD, m);
        m.waitTillDone();
        
        //now we should have SOME toplevelT
        assertNotNull("no toplevelT????", session.queryOnce("toplevelT(_,_,_,_)"));
        //and checkTreeLinks should say "yes"
        assertNotNull("checkTreeLinks reports errors", session.queryOnce("checkTreeLinks"));      
        


        IResourceVisitor renamer = new IResourceVisitor() {
            public boolean visit(IResource resource) throws CoreException {
                switch (resource.getType()) {
                case IResource.FOLDER:
                    return true;
                case IResource.FILE:
                    IFile file = (IFile) resource;
                    file.move(file.getFullPath().addFileExtension("orig"),
                            true, null);
                    break;
                case IResource.PROJECT:
                    return true;
                default:
                    throw new IllegalStateException("Unexpected resource type.");                    
                }
                return false;
            }
        };

        project.getFolder(packageName).accept(renamer);
        

        //next, we use gen_tree on each toplevelT node known to the system.
        //as a result we should be able to regenerate each and every source
        // file we consulted
        //in the first step
        String query = "toplevelT(ID,_,FILENAME,_),gen_tree(ID,CONTENT)";
        
        List results = session.queryAll(query);
        for (Iterator iter = results.iterator(); iter.hasNext();) {
            Map result = (Map) iter.next();
            String filename = result.get("FILENAME").toString();
            String content = result.get("CONTENT").toString();
            System.out.println(content);
            assertTrue("problems writing generated file.", createFile(filename,
                    content).isAccessible());            
        }

        //refetch cus
        cus = getCompilationUnits( packageName);

        //normalize again (now the generated source)
        for (int i = 0; i < cus.length; i++) {
            ICompilationUnit cu = cus[i];
            normalizeCompilationUnit(cu);

        }
        //build again.(the generated source)
        project.build(IncrementalProjectBuilder.INCREMENTAL_BUILD, null);

        //now, visit each file in the binFolder, that has the .class extension.
        //and compare it to the respective original class file (which should
        // have the same name + .orig)
        IResourceVisitor comparator = new IResourceVisitor() {
            public boolean visit(IResource resource) throws CoreException {
                switch (resource.getType()) {
                case IResource.FOLDER:
                    return true;
                case IResource.FILE:
                    IFile file = (IFile) resource;
                	if(!file.getFileExtension().equals("class")) return false;
                	
                	IFile orig = ResourcesPlugin.getWorkspace().getRoot().getFile(file.getFullPath().addFileExtension("orig"));
                	assertTrue("original class file not accessible: "+orig.getFullPath().toString(),orig.isAccessible());
                	//both files should be of EXACTLY the same size:
                	BufferedReader origReader = new BufferedReader(new InputStreamReader(orig.getContents()));
                	BufferedReader genReader = new BufferedReader(new InputStreamReader(file.getContents()));
                	int origR=0;
                	int genR=0;
                	int i=0;
                	for( i=0;origR!=-1&&genR!=-1;i++){
                	    try {
                            origR= origReader.read();
                            genR= genReader.read();
                            assertTrue("orig and generated file differ at position "+i,origR==genR);
                        } catch (IOException e) {                        
                            org.cs3.pl.common.Debug.report(e);
                        }                	    
                	}
                	org.cs3.pl.common.Debug.info("compared "+i+" chars succsessfully.");
                    return false;

                }
                return false;
            }
        };
        project.getFolder(packageName).accept(comparator);
    }
    protected void setUp() throws Exception {     
        super.setUp(); 
        PrologInterface pif = getTestJLMPProject().getPrologInterface();
        pif.start();
        session=pif.getSession();
        setTestDataLocator(JLMPPlugin.getDefault().getResourceLocator("testdata-roundtrip"));
        
        install(packageName);
    }
    protected void tearDown() throws Exception {     
        super.tearDown();
        PrologInterface pif = getTestJLMPProject().getPrologInterface();
        session.dispose();
        pif.stop();
        //uninstall(packageName);
    }
    public void tearDownOnce() {
        super.tearDownOnce();
        org.cs3.pl.common.Debug.info("tearDownOnce caled for key  " + getKey());
        //		try {
        //			deleteProject("Converter");
        //		} catch (CoreException e) {
        //			e.printStackTrace();
        //		}
        
        
    }

    public static Test suite() {
        TestSuite s = new TestSuite();
        for (int i = 1; i < 2; i++)
            s
                    .addTest(new PseudoRoundTripTest("testIt",
                            generatePackageName(i)));
        return s;
    }

    /**
     * @param i
     * @return
     */
    private static String generatePackageName(int n) {
        int desiredLength = 4;
        String number = String.valueOf(n);
        int padLength = desiredLength - number.length();
        StringBuffer sb = new StringBuffer("test");
        for (int i = 0; i < padLength; i++)
            sb.append('0');
        sb.append(number);
        return sb.toString();
    }

}