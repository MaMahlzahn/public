<!DOCTYPE doctype PUBLIC "-//w3c//dtd html 4.0 transitional//en"><html><head><title>A Program Annotation Facility for the Java Programming Language</title></head>

<body>
<center>
<h2>
A Program Annotation Facility for the Java<sup><font size="-1">tm</font></sup>
Programming Language</h2></center>

<center>
<h3>JSR-175 Public Draft Specification</h3></center>

<hr>
<br>
<h2>I. Introduction</h2>

This document describes a simple <i>program annotation facility</i> for the
Java programming language.  This facility allows developers to define custom
<i>annotation types</i> and to <i>annotate</i> fields, methods, classes, and
other program elements with <i>annotations</i> corresponding to these types.
These annotations do not directly affect the semantics of a program.
Development and deployment tools can, however, read these annotations and
process them in some fashion, perhaps producing additional Java programming
language source files, XML documents, or other artifacts to be used in
conjunction with the program containing the annotations.  For example, a tool
called a <i>stub generator</i> could generate remote procedure call stubs
as directed by annotations indicating which methods were designed for
remote use.

<p>As another example of the sort of thing one could do with annotations,
consider the familiar <tt>@deprecated</tt> tag.  This tag does not affect the
behavior of deprecated elements, but tells the compiler to emit warnings when
annotated elements are used.  The Javadoc tool also uses these annotations to
generate appropriate documentation of the deprecated status of API elements.
The deprecation facility was implemented in an ad hoc fashion using
documentation comments, but could have been implemented atop a program
annotation facility, had one existed at the time the deprecation facility was
designed.

<p>A second example of ad hoc program annotation already present in the Java
platform is the <tt>transient</tt> modifier.  The presence or absence of this
modifier does not affect the semantics of a field, but it may be queried at
runtime by the libraries that comprise the serialization subsystem as part of
the serialization process.  It is also queried at documentation generation
time by the Javadoc utility as part of the process of generating documentation
for the serialized form of the class.

</p><p>Since many annotations will be used only by development tools such
as stub generators, it makes little sense to retain all annotations at run
time; doing so could increase run-time memory-footprint and harm performance.
There are, however, some annotation types that are useful at run time, and
some that are useful in tools that only have access to class files (not source
files).  Therefore, certain annotations are stored by the compiler in <i>class
file attributes</i> (JVMS 4.7), and some of these annotations are then made
available for inspection at runtime via new reflective APIs.

</p><p>The program annotation facility consists of several parts:
</p><ol>
<li>
<a href="#declare">A syntax for declaring annotation types</a>
</li><li>
<a href="#annotation">A syntax for annotating program elements</a>
</li><li>
<a href="#meta">A set of standard <i>meta-annotation types</i> for specifying
the use of annotation types</a> (and <a href="#other_annotation_types">one additional standard annotation type</a>)
</li><li>
<a href="#query_api">An API for reading annotations</a>
</li><li>
<a href="#library_support">Library Support for Annotations</a>
</li><li>
<a href="#class_file">A specification for how annotations are recorded by
compilers in class file attributes</a>
</li></ol>

<a name="declare"></a><h2>II. Declaring Annotation Types</h2>

Every annotation has an <i>annotation type</i> associated with it.  In order
to create an annotation type, you must declare it with an <i>annotation type
declaration</i>.  In addition to enabling a family of annotations, declaring
an annotation type creates an interface that can be used to read those
annotations.  Annotation types can also be used in the definition of other
annotation types, giving rise to annotation types with deep structure, and
allowing substructures to be reused.  Annotation types share the same
namespace as ordinary class and interface types.

<p>An annotation type declaration takes the form of a highly restricted
interface declaration.  Annotation type declarations are legal wherever
interface declarations are legal, and have the same scope and accessibility.
To distinguish an annotation type declaration from an ordinary interface
declaration, the keyword <tt>interface</tt> is replaced by
<tt>@interface</tt>.  Note that the at sign (<tt>@</tt>) and the keyword
<tt>interface</tt> are two distinct tokens; technically it is possible to
separate them with whitespace, but convention dictates that this is not done.

<p>The following restrictions are imposed on annotation type declarations:
<ol>
<li>No <tt>extends</tt> clause is permitted.  (Annotation types automatically
extend a new marker interface, <tt>java.lang.annotation.Annotation</tt>.)

<li>Methods must not have any parameters.
<li>Methods must not have any type parameters (in other words, generic methods
are prohibited).
<li>Method return types are restricted to primitive types, <tt>String</tt>,
<tt>Class</tt>, enum types, annotation types, and arrays of the preceding
types.
<li>No <tt>throws</tt> clause is permitted.
<li>Annotation types must not be parameterized.
</ol>
Each method declaration in an annotation type declaration defines
a <i>member</i> of the annotation type.  Annotation types can have zero or more
members.  Annotation types must not contain members of the same annotation
type, either directly or indirectly.  In other words, this is illegal:
<pre>
<b>// Illegal self-reference!!</b>
@interface SelfRef {
    SelfRef value();
}
</pre>
and so is this:
<pre>
<b>// Illegal circularity!!</b>
@interface Ping {
    Pong value();
}

@interface Pong {
    Ping value();
}
</pre>

<p>The interface created by an annotation type declaration inherits
several additional members from <tt>java.lang.annotation.Annotation</tt>,
which are the implicitly declared methods corresponding to the instance
methods  <tt>java.lang.Object</tt> (JLS 9.2).  These methods are <i>not</i>,
however, considered to be members of the annotation type, and it is illegal
to use them in annotations.

<p>Unlike method declarations in ordinary interfaces, a <i>default
value</i> may be specified for an annotation type member.  This is done by
following its (empty) parameter list with the keyword <tt>default</tt> and the
default value of the member.  Note that defaults are applied dynamically at
the time annotations are read; default values are <i>not</i> compiled into
annotations.  Thus, changing a default value affects annotations even in
classes that were compiled before the change was made (presuming these
annotations lack an explicit value for the defaulted member).

<p>The grammar for an annotation type declaration is shown below:
</p><pre>
    <i>AnnotationTypeDeclaration:
        InterfaceModifiers<sub>opt</sub></i> @ interface <i>Identifier AnnotationTypeBody

    AnnotationTypeBody:
        </i>{</i> AnnotationTypeMemberDeclarations<sub>opt</sub> </i>}<i>

    AnnotationTypeMemberDeclarations:
	AnnotationTypeMemberDeclaration
	AnnotationTypeMemberDeclarations AnnotationTypeMemberDeclaration

    AnnotationTypeMemberDeclaration:
        AbstractMethodModifiers<sub>opt</sub> Type Identifier ( ) DefaultValue<sub>opt</sub> ;
        ConstantDeclaration
        ClassDeclaration
        InterfaceDeclaration
        EnumDeclaration
        AnnotationTypeDeclaration
        </i>;</i>

    DefaultValue:
        </i>default<i> MemberValue</i>
</pre>
All of the same restrictions apply to <tt><i>InterfaceModifiers</i></tt> and
<tt><i>AbstractMethodModifiers</i></tt> as apply for ordinary interface
declarations. (By convention, no <tt><i>AbstractMethodModifiers</i></tt>
should be present.) The <tt><i>Type</i></tt> is restricted to primitive types,
<tt>String</tt>, <tt>Class</tt>, enum types, annotation types, and arrays of
the preceding types.  It is permissible to use <i>bounded wildcards</i> to
parameterize the <tt>Class</tt> return type, and the compiler must enforce
such bounds on annotations.  (See the JSR-14 specification for a description
of bounded wildcards.)  Note that this does not conflict with the
prohibition on generic methods, as wildcards eliminate the need for an
explicit type parameter.

<p>A <i>MemberValue</i> is used to specify a default value, whose type
must be appropriate for the member whose default is being specified.  The
detailed grammar and semantic restrictions on <i>MemberValue</i> are contained
in Section III, below.

<h3>Examples</h3>
<p>The following annotation type declaration defines an annotation type with several
members: <pre>
<b>// Normal annotation type declaration with several members</b>

/**
 * Describes the "request-for-enhancement" (RFE) that led to the presence of 
 * the annotated API element.
 */
public @interface RequestForEnhancement {
    int    id();        // Unique ID number associated with RFE
    String synopsis();  // Synopsis of RFE
    String engineer();  // Name of engineer who implemented RFE
    String date();      // Date RFE was implemented
}
</pre>

The following annotation type declaration defines an annotation type with no
members, termed a <i>marker</i> annotation type:
<pre>
// <b>Marker annotation type declaration</b>

/**
 * Annotation with this type indicates that the specification of the
 * annotated API element is preliminary and subject to change.
 */
public @interface Preliminary { }
</pre>
By convention, the name of the sole member in a single-member annotation type
is <tt>value</tt>.  (Linguistic support for this convention is provided by the 
<a href="#single-member-annotation"><i>single member annotation</i></a>
construct; you must obey the convention in order to make use of the
construct.) The convention is illustrated in the following annotation type
declaration:
<pre>
<b>// Single-member annotation type declaration</b>

/**
 * Associates a copyright notice with the annotated API element.
 */
public @interface Copyright {
    String value();
}
</pre>

The following annotation type declaration defines a single-member annotation type whose
sole member has an array type:
<pre>
<b>// Single-member annotation type declaration with array-typed member</b>

/**
 * Associates a list of endorsers with the annotated class.
 */
public @interface Endorsers {
    String[] value();
}
</pre>

Here is an example of <i>complex annotation types</i>, annotation types that
contain one or more members whose types are also annotation types.
<pre>
<b>// Complex Annotation Type</b>

/**
 * A person's name.  This annotation type is not designed to be used
 * directly to annotate program elements, but to define members
 * of other annotation types.
 */
public @interface Name {
    String first();
    String last();
}

/**
 * Indicates the author of the annotated program element.
 */
public @interface Author {
    Name value();
}

/**
 * Indicates the reviewer of the annotated program element.
 */
public @interface Reviewer {
    Name value();
}
</pre>

<p>The following annotation type declaration provides default values for two of its
four members:
<pre>
<b>// Annotation type declaration with defaults on some members</b>
public @interface RequestForEnhancement {
    int    id();       // No default - must be specified in each annotation
    String synopsis(); // No default - must be specified in each annotation
    String engineer()  default "[unassigned]";
    String date()      default "[unimplemented]";

}
</pre>

<p>The following annotation type declaration shows a <tt>Class</tt> annotation whose
value is restricted by a bounded wildcard.
<pre>
<b>// Annotation type declaration with bounded wildcard to restrict <tt>Class</tt> annotation</b>
/**
 * The annotation type declaration below presumes the existence of this interface,
 * which describes a formatter for Java programming language source code.
 */
public interface Formatter { ... }

/**
 * Designates a formatter to pretty-print the annotated class.
 */
public @interface PrettyPrinter {
    Class&lt;? extends Formatter&gt; value();
}
</pre>

<a name="annotation"></a><h2>III. Annotations</h2>

An <i>annotation</i> is a new kind of modifier containing an annotation type
(as defined in the previous section) and zero or more <i>member-value
pairs</i>, each of which associates a value with a different member of the
annotation type.  Annotations must contain a member-value pair for
<i>every</i> member of the corresponding annotation type, except for those
members with default values.  Annotations may, but are not required to,
contain member-value pairs for members with default values.  The purpose of
an annotation is simply to associate information with the annotated program
element.

<p>Annotations may be used as modifiers in any declaration, whether class,
interface, field, method, parameter, constructor, enum, or
local variable.  Annotations may also be used on enum constants
(which are implicit field declarations).  Such annotations are placed
immediately before the enum constant they annotate.

<p>Finally, annotations may be used on package declarations, with the
restriction that at most one annotated package declaration is permitted for a
given package. The manner in which this restriction is enforced must, of
necessity, vary from implementation to implementation.  The following scheme
is <i>strongly</i> recommended for file-system-based implementations: The sole
annotated package declaration, if it exists, is placed in a source file called
<tt>"package-info.java"</tt> in the directory containing the source files for
the package.  This file does <i>not</i> contain the source for a class called
package-info.java; indeed it would be illegal for it to do so, as
<tt>package-info</tt> is not a legal identifier.  Typically
<tt>"package-info.java"</tt> contains <i>only</i> a package declaration,
preceded immediately by the annotations on the package.  While the file could
technically contain the source code for one or more package-private classes,
it would be very bad form.

<p>It is recommended that <tt>package-info.java</tt>, if it is present, take
the place of <tt>package.html</tt> for <tt>javadoc</tt> and other similar
documentation generation systems.  If this file is present, the documentation
generation tool should ignore <tt>package.html</tt> and look instead for the
package documentation comment immediately preceding the (possibly annotated)
package declaration in <tt>package-info.java</tt>.  In this way,
<tt>package-info.java</tt> becomes the sole repository for package level
annotations and documentation.  If, in future, it becomes desirable to add any
other package-level information, this file should prove a convenient home for
this information.

<p>The annotation type (interface) corresponding to an annotation
must be accessible at the point where the annotation is used.  A declaration
cannot have multiple annotations for the same annotation type.  Annotations are
conventionally placed before all other modifiers, but this is not a
requirement; they may be freely intermixed with other modifiers.

<p>There are three kinds of annotations.  The first (<i>normal annotation</i>)
is fully general.  The others (<i>marker annotation</i> and <i>single-member
annotation</i>) are merely shorthands.
</p><pre>
    <i>Annotation:
        NormalAnnotation
        MarkerAnnotation
        SingleMemberAnnotation</i>
</pre>
A normal annotation is used to annotate a program element:
<pre>
    <i>NormalAnnotation:</i>
        @ <i>TypeName</i> ( <i>MemberValuePairs<sub>opt</sub></i> )

    <i>MemberValuePairs:
        MemberValuePair
        MemberValuePairs</i> , <i>MemberValuePair</i>

    <i>MemberValuePair:
        SimpleName</i> = <i>MemberValue

    MemberValue:
        ConditionalExpression
        Annotation
        MemberValueArrayInitializer

    MemberValueArrayInitializer:
        </i>{</i> MemberValues<sub>opt</sub></i> ,<i><sub>opt</sub> </i>}<i>

    MemberValues:
        MemberValue
        MemberValues </i>,<i> MemberValue</i>
</pre>
<p>Note that the at-sign (<tt>@</tt>) is a token unto itself. Technically
it is possible to put whitespace in between the at-sign and the
<tt><i>TypeName</i></tt>, but convention dictates that this is not done.

<p><tt><i>TypeName</i></tt> may be a fully qualified or simple annotation type
name.  A simple name may be used to refer to an annotation type defined in
another package if it is imported, either singly:
<pre>
    import <i>PackageName</i>.<i>SimpleName</i>;
</pre>
or on demand:
<pre>
    import <i>PackageName</i>.*;
</pre>
These are normal import declarations (JLS 7.5.1, 7.5.2): annotation types are
imported in the same fashion as classes and interfaces.  Any annotation types
defined in <tt>java.lang</tt> would be implicitly imported on demand.
<p>
<p>The <tt><i>SimpleName</i></tt> in a <i>MemberValuePair</i>
must be the name of one of the members of the annotation type identified by
<tt><i>Name</i></tt> in the containing annotation.  (In other words, the
simple name in a member-value pair must also be a method name in the
interface identified by <tt><i>Name</i></tt>.)  The return type of this method
defines the <i>member type</i> of the member-value pair.
<p>
If the member type is not an annotation type or an array type,
<tt><i>MemberValue</i></tt> must be a
<tt><i>ConditionalExpression</i></tt> (JLS 15.25) whose type is <i>assignment compatible</i> (JLS
5.2) with the member type.  (A <tt><i>ConditionalExprression</i></tt>
is simply an expression without assignments, and not necessarily an
expression involving the conditional operator (<tt>? :</tt>).)
If member type is a primitive type or <tt>String</tt>, the
<tt><i>ConditionalExpression</i></tt> must
be a <i>constant expression</i> (JLS 15.28).  
If the member type is <tt>Class</tt>, the value must be a
<i>class literal</i> (JLS 15.8.2).  If the member type is an enum
type, the value must be the simple (unqualified) name of an <i>enum
constant</i>.  Loosely speaking, no matter what the member type, the value
must be a compile-time constant.  Note that <tt>null</tt> is not a legal
member value for any member type.
<p>
If the member type is an annotation type, the <tt><i>MemberValue</i></tt> must
be an <tt><i>Annotation</i></tt> with the same type.

<p>If the member type is an array type, the <tt><i>MemberValue</i></tt> may be
either a <tt><i>MemberValueArrayInitializer</i></tt> or a
<tt><i>MemberValue</i></tt> that is legal for the array's element type (as
defined above).  A <tt><i>MemberValueArrayInitializer</i></tt> is similar
to a normal array initializer (JLS 10.6), except that annotations are
permitted in place of expressions.  Each
<tt><i>MemberValueInitializer</i></tt> (analogous to a <i>variable
initializer</i> in an array initializer) must be a legal
<tt><i>MemberValue</i></tt> for the array's element type (as defined above).

<p>If the member type is an array type and the corresponding
<tt><i>MemberValue</i></tt> is not a
<tt><i>MemberValueArrayInitializer</i></tt>, an array value
whose sole element is the value represented by the <tt><i>MemberValue</i></tt>
is associated with the member.  In other words, it is permissible to omit the
curly braces when a single-element array is to be associated with an
array-valued annotation type member.

<p>Note that the array's element type cannot be an array type, that is, nested array types are not permitted as member types.  (While the annotation syntax would permit this, the annotation type declaration syntax would not.)

<p>Note that it is possible to annotate an annotation type declaration.  Such
annotations are known as <i>meta-annotations</i>.  An annotation type may
be used to annotate its own declaration.  More generally, circularities in the
transitive closure of the "annotates" relation are permitted.  For example, it
is legal to annotate an annotation type declaration with another annotation
type, and to annotate the latter type's declaration with the former type.
(The <a href="#meta">standard meta-annotation types</a> contain several such
circularities.)

<p>
Here is an example of a normal annotation:
<pre>
<b>// Normal annotation</b>
@RequestForEnhancement(
    id       = 2868724,
    synopsis = "Provide time-travel functionality",
    engineer = "Mr. Peabody",
    date     = "4/1/2004"
)
public static void travelThroughTime(Date destination) { ... }
</pre>
Note that the types of the annotations in the examples in this section are the
annotation types defined in the examples in <a href="#declare">Section II</a>.

<p>
<a name=marker-annotation></a>
The second form of annotation, <i>marker annotation</i>, is
a  shorthand designed for use with marker annotation types:
<pre>
    <i>MarkerAnnotation:</i>
        @ <i>TypeName</i>
</pre>
It is simply a shorthand for the normal annotation:
<pre>
        @<i>TypeName</i>()
</pre>
Example:
<pre><b>// Marker annotation</b>
@Preliminary public class TimeTravel { ... }
</pre>
Note that it is legal to use marker annotations for annotation types with
members, so long as all the members have default values.

<p><a name=single-member-annotation></a>
The third form of annotation, <i>single-member annotation</i>, is
a shorthand designed for use with single-member annotation types:
<pre>    <i>SingleMemberAnnotation:</i>
        @ <i>TypeName</i> ( <i>MemberValue</i> )
</pre>
It is shorthand for the normal annotation:
<pre>
        @<i>TypeName</i> ( value = <i>MemberValue</i> )
</pre>
Example:
<pre>
<b>// Single-member annotation</b>
@Copyright("2002 Yoyodyne Propulsion Systems, Inc., All rights reserved.")
public class OscillationOverthruster { ... }
</pre>
Example with array-valued single-member annotation:
<pre>
<b>// Array-valued single-member annotation</b>
@Endorsers({"Children", "Unscrupulous dentists"})
public class Lollipop { ... }
</pre>

Example with single-element array-valued single-member annotation (note that
the curly braces are omitted):
<pre>
<b>// Single-element array-valued single-member annotation</b>
@Endorsers("Epicurus")
public class Pleasure { ... }
</pre>

Example with complex annotation:
<pre>
<b>// Single-member complex annotation</b>
@Author(@Name(first = "Joe", last = "Hacker"))
public class BitTwiddle { ... }
</pre>
Note that it is legal to use single-member annotations for annotation types
with multiple members, so long as one member is named <tt>value</tt>,
and all other members have default values.

<p>Here is an example of an annotation that takes advantage of default values:
<pre>
<b>// Normal annotation with default values</b>
@RequestForEnhancement(
    id       = 4561414,
    synopsis = "Balance the federal budget"
)
public static void balanceFederalBudget() {
    throw new UnsupportedOperationException("Not implemented");
}
</pre>

<p>Here is an example of an annotation with a <tt>Class</tt> member whose
value is restricted by the use of a bounded wildcard.
<pre>
<b>// Single-member annotation with <tt>Class</tt> member restricted by bounded wildcard</b>
// The annotation presumes the existence of this class.
class GorgeousFormatter implements Formatter { ... }

@PrettyPrinter(GorgeousFormatter.class)
public class Petunia { ... }

<b>// This annotation is illegal, as String is not a subtype of Formatter!!</b>
@PrettyPrinter(String.class) public class Begonia { ... }
</pre>

<a name="meta"></a><h2>IV. Standard Meta-Annotation Types</h2>
Annotation types designed for annotating annotation type declarations
are called <i>meta-annotation types</i>.  Several
are provided in <tt>java.lang.annotation</tt>.  Some of these meta-annotation
types restrict the use of the types they annotate.

<p>The <tt>ElementType</tt> enumerated type is used in conjunction with the 
<tt>Target</tt> meta-annotation type to indicate where an annotation type may
be used:

<pre>/**
 * A program element type.  The constants of this enumerated type
 * provide a simple classification of the declared elements in a
 * Java program.
 *
 * These constants are used in conjunction with the {@link Target}
 * meta-annotation type to specify where it is legal to use an
 * annotation type.
 */
public enum ElementType {
    /** Class, interface or enum declaration */
    TYPE,

    /** Field declaration (includes enum constants) */
    FIELD,

    /** Method declaration */
    METHOD,

    /** Parameter declaration */
    PARAMETER,

    /** Constructor declaration */
    CONSTRUCTOR,

    /** Local variable declaration */
    LOCAL_VARIABLE,

    /** Annotation type declaration */
    ANNOTATION_TYPE,

    /** Package declaration */
    PACKAGE
}

/**
 * Indicates the kinds of program element to which an annotation type
 * is applicable.  If a <tt>Target</tt> meta-annotation is not present on an
 * annotation type declaration, the declared type may be used on any
 * program element.  If such a meta-annotation is present, the compiler
 * will enforce the specified usage restriction.
 *
 * For example, this meta-annotation indicates that the declared type is
 * itself a meta-annotation type.  It can only be used on annotation type
 * declarations:
 *
 *    @Target(ANNOTATION_TYPE)
 *    public @interface MetaAnnotationType {
 *        ... 
 *    }
 *
 * This meta-annotation indicates that the declared type is intended solely
 * for use as a member type in complex annotation type declarations.  It
 * cannot be used to annotate anything directly:
 *
 *    @Target({}) 
 *    public @interface MemberType {
 *        ...
 *    }
 *
 * It is a compile-time error for a single <tt>ElementType</tt> constant to
 * appear more than once in a <tt>Target</tt> annotation.  For example, the
 * following meta-annotation is illegal:
 *
 *    <b>// This annotation is illegal!</b>
 *    @Target({FIELD, METHOD, FIELD})
 *    public  @interface Bogus {
 *        ...
 *    }
 */
@Documented @Retention(RUNTIME) @Target(ANNOTATION_TYPE)
public @interface <b>Target</b> {
    ElementType[] value;
}
</pre>
Note that the <tt>Target</tt> annotation type's own declaration exemplifies
its use, as well as the use of the <tt>Documented</tt> meta-annotation type,
shown below.

<p>The <tt>Documented</tt> meta-annotation type is used to indicate
that annotations with a type should be documented:

<pre>
/**
 * Indicates that annotations with a type are to be documented by javadoc
 * and similar tools by default.  This type should be used to annotate the 
 * declarations of types whose annotations affect the use of annotated
 * elements by their clients.  If a type declaration is annotated with
 * <tt>Documented</tt>, its annotations become part of the public API
 * of the annotated elements.
 */
@Documented @Target(ANNOTATION_TYPE)
public @interface <b>Documented</b> {
}
</pre>
The <tt>RetentionPolicy</tt> enumerated type is used in conjunction with the
<tt>Retention</tt> meta-annotation type to indicate how long an annotation is
to be retained:

<pre>
<a name = "RetentionPolicy">
/**
 * Annotation retention policy.  The constants of this enumerated type
 * describe the various policies for retaining annotations.  They are used
 * in conjunction with the {@link Retention} meta-annotation type to specify
 * how long annotations are to be retained.
 */
</a>
public enum RetentionPolicy {
    /**
     * Annotations are to be discarded by the compiler.
     */
    SOURCE,

    /**
     * Annotations are to be recorded in the class file by the compiler
     * but need not be retained by the VM at run time.  This is the default
     * behavior.
     */
    CLASS,

    /**
     * Annotations are to be recorded in the class file by the compiler and
     * retained by the VM at run time, so they may be read reflectively.
     *
     * @see java.lang.reflect.AnnotatedElement
     */
    RUNTIME
}

/**
 * Indicates how long annotations with the annotated type are to
 * be retained.  If no <tt>Retention</tt> annotation is present on
 * an annotation type declaration, the retention policy defaults to
 * <tt>CLASS</tt>.
 *
 * A <tt>Target</tt> meta-annotation has effect only if the meta-annotated
 * type is use directly for annotation.  It has no effect if the meta-annotated
 * type is used as a member type in another annotation type.
 */
@Documented @Retention(RUNTIME) @Target(ANNOTATION_TYPE)
public @interface <b>Retention</b> {
    RetentionPolicy value();
}
</pre>

The <tt>Inherited</tt> meta-attribute is used to indicate that annotations
with a type are to be automatically inherited by subclasses or subclass
methods:
<pre>
/**
 * Indicates that an annotation type is automatically inherited.  If
 * an <tt>Inherited</tt> meta-annotation is present on an annotation type
 * declaration, and the user queries the annotation type on a class
 * declaration, and the class declaration has no annotation for this type,
 * then the class's superclass will automatically be queried for the
 * annotation type.  This process will be repeated until an annotation for this
 * type is found, or the top of the class hierarchy (<tt>Object</tt>)
 * is reached.  If no superclass has an annotation for this type, then
 * the query will indicate that the class in question has no such annotation.
 *
 * If an <tt>Inherited</tt> meta-annotation is present on an annotation type
 * declaration, and the user queries the annotation type on an instance method
 * declaration, and the declaration has no annotation for this type, then 
 * the query method will automatically search for a superclass method that is
 * overridden by the annotated method.  If such a method is found, it will be
 * queried for this annotation type.  This process will be repeated until an
 * annotation for this type is found or the top of the class hierarchy
 * (<tt>Object</tt>) is reached.  If the top of the class hierarchy is reached
 * without finding  an annotation for this type, then the query will indicate
 * that the method in question has no such annotation.
 *
 * Note that this meta-annotation type has no effect if the annotated
 * type is used to annotate anything other than a class or instance method
 * declaration.  Note also that this meta-annotation only causes annotations
 * to be inherited from superclasses; annotations on implemented interfaces
 * have no affect.
 */
@Documented @Retention(RUNTIME) @Target(ANNOTATION_TYPE)
public @interface <b>Inherited</b> {
}
</pre>

<a name="query_api"></a>

<a name="other_annotation_types">
<h2>V. Other Standard Annotation Types</h2></a>

<p>Programmers occasionally overload a method declaration when they mean
to override it.  The classic example concerns the <tt>equals</tt> method.
Programmers write the following:
<pre>
    public boolean equals(<b>Foo</b> that) { ... }
</pre>
when they mean to write:
<pre>
    public boolean equals(<b>Object</b> that) { ... }
</pre>
This is perfectly legal, but class <tt>Foo</tt> inherits the <tt>equals</tt>
implementation from <tt>Object</tt>, which can cause some very subtle bugs.
The following standard annotation type provides a way to avoid this trap:
<pre>package java.lang;
/**
 * Indicates that a method declaration is intended to override a concrete
 * method declaration in a superclass.  If a method is annotated with
 * this type but does not override a superclass method, compilers are
 * required to generate an error message.
 */
@Retention(SOURCE) @Target(METHOD)
public @interface Overrides { }
</pre>

This annotation type allows the programmer to declare his belief that a method
declaration overrides a superclass method:
<pre>
    @Overrides public boolean equals(Foo that) { ... }
</pre>
The compiler checks whether method actually overrides a superclass method,
and reports an error if it does not, nipping the problem in the bud.

<p>Note that this annotation type is not a fundamental part of this
specification, but an initial use of the facility in the Java programming
language.

<h2>VI. Reading Annotations</h2>

Annotation consumers may be divided into three groups:
<ol>
<li>
"Introspectors" - Programs that query <i>runtime-visible</i> annotations of
their own program elements.  These programs will load both annotated
classes and annotation interfaces into the virtual machine.  (By
runtime-visible, we mean annotations whose <a href = #RetentionPolicy>
<i>retention policy</i></a> is <tt>RUNTIME</tt>.)
<li>
"Specific Tools" - Programs that query known annotation types of arbitrary
external programs.  Stub generators, for example, fall into this category.
These programs will read annotated classes without loading them into the
virtual machine, but will load annotation interfaces.
<li>
"General Tools" - Programs that query arbitrary annotations of arbitrary
external programs (such as compilers, documentation generators, and class
browsers).  These programs will load neither annotated classes nor annotation
interfaces into the virtual machine.  Such programs are said to operate "at
arm's length."
</ol>

<h3>Reading Annotations at Run Time</h3>
The Java core reflection API is extended to allow "introspectors" 
to query runtime-visible annotations of their own program elements.  Types
that represents a program element at runtime are extended to implement the
<tt>java.lang.reflect.AnnotatedElement</tt> interface.  The affected classes
are <tt>java.lang.Class</tt>, which allows class annotations to be read;
<tt>java.lang.reflect.AccessibleObject</tt>, which allows field, method,
constructor, and enum constant annotations to be read; and java.lang.Package,
which allows package annotations to be read.

<pre>
/**
 * Represents an annotated element of the program currently running in this
 * JVM.  This interface allows annotations to be read reflectively.  All
 * annotations returned by methods in this interface are serializable.
 *
 * If an annotation object returned by a method in this interface
 * contains (directly or indirectly) one or more <tt>Class</tt> members
 * that refer to a class that is not accessible in this JVM, attempting
 * to read the class by calling the relevant <tt>Class</tt>-returning
 * method on the returned annotation (or an annotation referred to by
 * that annotation) will cause a {@link TypeNotPresentException}
 * to be thrown.
 */
public interface AnnotatedElement {
    /**
     * Returns <tt>true</tt> if an annotation for the specified type
     * is present on this element, else <tt>false</tt>.  This method
     * is designed primarily for convenient access to marker annotations.
     *
     * @param annotationType the <tt>Class</tt> object corresponding to the
     *        annotation type
     * @return <tt>true</tt> if an annotation for the specified annotation
     *     type is present on this element, else <tt>false</tt>
     * @throws NullPointerException if <tt>annotationType</tt> is null
     */
     boolean isAnnotationPresent(Class&lt;? extends Annotation&gt; annotationType);

    /**
     * Returns this element's annotation for the specified type if
     * such an annotation is present, else <tt>null</tt>.
     *
     * @param annotationType the <tt>Class</tt> object corresponding to the 
     *        annotation type
     * @return this element's annotation for the specified annotation type if
     *     present on this element, else <tt>null</tt>
     * @throws NullPointerException if <tt>annotationType</tt> is null
     */
    &lt;T extends Annotation&gt; T getAnnotation(Class&lt;T&gt; annotationType);

    /**
     * Returns all annotations present on this element.  (Returns an array
     * of length zero if this element has no annotations.)
     *
     * @return all annotations present on this element
     */
    Annotation[] getAnnotations();

    /**
     * Returns all annotations that are <i>directly</i> present on this
     * element.  Unlike the other methods in this interface, this method
     * ignores inherited annotations.  (Returns an array of length zero if
     * no annotations are directly present on this element.)
     *
     * @return All annotations directly present on this element
     */
    Annotation[] getDeclaredAnnotations();
}
</pre>
To allow annotations on parameters to be read, a new method is added to
<tt>java.lang.reflect.Method</tt> and <tt>java.lang.reflect.Constructor</tt>.
<pre>
    /**
     * Returns an array of arrays that represent the annotations on the formal
     * parameters, in declaration order, of the method represented by
     * this <tt>Method</tt> object. (Returns an array of length zero if the
     * underlying method is parameterless.) The annotation objects contained
     * in the returned arrays are serializable.
     *
     * @returns an array of arrays that represent the annotations on the formal
     *    parameters, in declaration order, of the method represented by this
     *    <tt>Method</tt> object
     */
    public Annotation[][] getParameterAnnotations();
</pre>
The following exception is added to java.lang:
<pre>
/**
 * Thrown when an application tries to access a type using a string
 * representing the type's name, but no definition for the type with
 * the specified name can be found.   This exception differs from
 * {@link ClassNotFoundException} in that <tt>ClassNotFoundException</tt>
 * is a checked exception, whereas this exception is unchecked.
 *
 * Note that this exception may be used when undefined type variables
 * are accessed as well as when types (e.g., classes, interfaces or
 * annotation tyes) are loaded.
 */
public class TypeNotPresentException extends RuntimeException {
   /**
    * Constructs a <code>TypeNotPresentException</code> for the named type
    * with the specified cause.
    *
    * @param typeName the fully qualified name of the unavailable type
    * @param cause the exception that was thrown when the system attempted to
    *   load the named type, or <tt>null</tt> if unavailable or inapplicable
    */
   public TypeNotPresentException(String typeName, Throwable cause);

   /**
    * Returns the fully qualified name of the unavailable type.
    *
    * @return the fully qualified name of the unavailable type
    */
   public String typeName();
}
</pre>

Here are examples of how these APIs can be used to read the annotations shown in Section III:
<pre>
<b>// Reading a normal annotation</b>
Method m = TimeTravel.class.getMethod("travelThroughTime", new Class[] {Date.class});
RequestForEnhancement rfe = m.getAnnotation(RequestForEnhancement.class);
int id = rfe.id();
String synopsis = rfe.synopsis();
String engineer = rfe.engineer();
String date = rfe.date();

<b>// Reading a marker annotation</b>
boolean isPreliminary = TimeTravel.class.isAnnotationPresent(Preliminary.class);

<b>// Reading a single-member annotation</b>
String copyrightHolder = 
    OscillationOverthruster.class.getAnnotation(Copyright.class).value();

<b>// Reading an array-valued single-member annotation</b>
String[] endorsers = Lollipop.class.getAnnotation(Endorsers.class).value();

<b>// Reading a single-member complex annotation</b>
Name author = BitTwiddle.class.getAnnotation(Author.class).value();
String firstName = author.first();
String lastName = author.last();
</pre>

The preceding APIs should also suffice for "specific tools" (which are willing
to load annotation interfaces into the virtual machine but not annotated
classes), assuming the existence of a tool that reads a class file without
loading the class, and returns a "class mirror" object that implements
<tt>AnnotatedElement</tt>.  General tools, however, will need to read
annotaions using an <a href="#arms_length">"at-arms-length" API</a>,
which allows annotations to be read without loading the annotated classes or
annotation interfaces into the virtual machine.

<p>One more method is added to the core reflection API.  In order to
distinguish an annotation type from a normal interface at run time, the
following method is added to java.lang.Class:
<pre>
/**
 * Returns true if this <tt>Class</tt> object represents an annotation type.
 * Note that if this method returns true, {@link #isInterface()} would also
 * return true, as all annotation types are also interfaces.
 *
 * @returns <tt>true</tt> if this class object represents an annotation type;
 *     <tt>false</tt> otherwise
 */
public boolean isAnnotationType();
</pre>

<a name="library_support">
<h2>VII. Library Support</h2></a>

This is the marker interface implemented by all annotation types.  Note that it refines the contract on the <tt>Object</tt> methods <tt>equals</tt> and <tt>toString</tt>, ensuring that <tt>Annotation</tt> instances may be meaningfully printed and used as map keys or set elements:
<pre>
package java.lang.annotation;

/**
 * Marker interface extended by every annotation interface.
 */
public interface Annotation {
    /**
     * Returns true if the specified object represents an annotation
     * that is logically equivalent to this one.  In other words,
     * returns true if the specified object is an instance of the same
     * annotation type as this instance, all of whose members are equal
     * to the corresponding member of this annotation, as defined below:
     * 
     *    Two corresponding primitive typed members whose values are
     *    <tt>x</tt> and <tt>y</tt> are considered equal if <tt>x == y</tt>,
     *    unless their type is <tt>float</tt> or <tt>double</tt>.
     *
     *    Two corresponding <tt>float</tt> members whose values
     *    are <tt>x</tt> and <tt>y</tt> are considered equal if
     *    <tt>Float.valueOf(x).equals(Float.valueOf(y))</tt>.
     *    (Unlike the <tt>==</tt> operator, NaN is considered equal
     *    to itself, and <tt>0.0f</tt> unequal to <tt>-0.0f</tt>.) 
     *
     *    Two corresponding <tt>double</tt> members whose values
     *    are <tt>x</tt> and <tt>y</tt> are considered equal if
     *    <tt>Double.valueOf(x).equals(Double.valueOf(y))</tt>.
     *    (Unlike the <tt>==</tt> operator, NaN is considered equal
     *    to itself, and <tt>0.0</tt> unequal to <tt>-0.0</tt>.)
     *
     *    Two corresponding <tt>String</tt>, <tt>Class</tt>, enum, or
     *    annotation typed members whose values are <tt>x</tt> and <tt>y</tt>
     *    are considered equal if <tt>x.equals(y)</tt>.  (Note that this
     *    definition is recursive for enum typed members.)
     *
     *    Two corresponding array typed members <tt>x</tt> and <tt>y</tt>
     *    are considered equal if <tt>Arrays.equals(x, y)</tt>, for the
     *    appropriate overloading of {@link java.util.Arrays#equals}.
     * 
     *
     * @return true if the specified object represents an annotation
     *     that is logically equivalent to this one, otherwise false
     */
    boolean equals(Object obj);

    /**
     * Returns a string representation of this annotation.  The details
     * of the representation are implementation-dependent, but the following
     * may be regarded as typical:
     *
     *   @com.acme.util.Name(first=Alfred, middle=E., last=Neuman)
     *
     *
     * @return a string representation of this annotation
     */
    String toString();
}
</pre>

In order to implement the <tt>equals</tt>, <tt>hashCode</tt>, and
<tt>toString</tt> for annotations, we need content-based <tt>equals</tt>,
<tt>hashCode</tt>, and <tt>toString</tt> methods for arrays.  The utility
class <tt>java.util.Arrays</tt> currently contains the <tt>equals</tt>
methods, but not the others.  Thus, we add the following methods to
<tt>java.util.Arrays</tt>:

<pre>
    <b>// hashCode methods</b>

    /**
     * Returns a hash code based on the contents of the specified array.
     * For any two <tt>long</tt> arrays <tt>a</tt> and <tt>b</tt>
     * such that <tt>Arrays.equals(a, b)</tt>, it is also the case that
     * <tt>Arrays.hashCode(a) == Arrays.hashCode(b)</tt>.
     *
     * The value returned by this method is the same value that would be
     * obtained by invoking the {@link List#hashCode() <tt>hashCode</tt>}
     * method on a {@link List} containing a sequence of {@link Long}
     * instances representing the elements of <tt>a</tt> in the same order.
     * If <tt>a</tt> is <tt>null</tt>, this method returns 0.
     *
     * @param the array whose hash value to compute
     * @return a content-based hash code for the array <tt>a</tt>
     */
    public static int hashCode(long a[]);
    
    // Analogous methods for each of the other seven primitive types (not shown)
    // plus these two for Object:
    
    /**
     * Returns a hash code based on the contents of the specified array.  If
     * the array contains other arrays as elements, the hash code is based on
     * their identities rather than their contents.  It is therefore
     * acceptable to invoke this method on an array that contains itself as an
     * element,  either directly or indirectly through one or more levels of
     * arrays.
     *
     * For any two arrays <tt>a</tt> and <tt>b</tt> such that
     * <tt>Arrays.equals(a, b)</tt>, it is also the case that
     * <tt>Arrays.hashCode(a) == Arrays.hashCode(b)</tt>.
     *
     * The value returned by this method is equal to the value that would
     * be returned by <tt>Arrays.asList(a).hashCode()</tt>, unless <tt>a</tt>
     * is <tt>null</tt>, in which case <tt>0</tt> is returned.
     *
     * @param the array whose content-based hash code to compute
     * @return a content-based hash code for the array <tt>a</tt>
     * @see #deepHashCode(Object[])
     */
    public static int hashCode(Object a[]);
    
    /**
     * Returns a hash code based on the "deep contents" of the specified
     * array.  If the array contains other arrays as elements, the
     * hash code is based on their contents and so on, ad infinitum.
     * It is therefore unacceptable to invoke this method on an array that
     * contains itself as an element, either directly or indirectly through
     * one or more levels of arrays.  The behavior of such an invocation is
     * undefined.
     *
     * For any two arrays <tt>a</tt> and <tt>b</tt> such that
     * <tt>Arrays.deepEquals(a, b)</tt>, it is also the case that
     * <tt>Arrays.deepHashCode(a) == Arrays.deepHashCode(b)</tt>.
     *
     * The computation of the value returned by this method is similar to
     * that of the value returned by {@link List#hashCode()} on a list
     * containing the same elements as <tt>a</tt> in the same order, with one
     * difference: If an element <tt>e</tt> of <tt>a</tt> is itself an array,
     * its hash code is computed not by calling <tt>e.hashCode()</tt>, but as
     * by calling the appropriate overloading of <tt>Arrays.hashCode(e)</tt>
     * if <tt>e</tt> is an array of a primitive type, or as by calling
     * <tt>Arrays.deepHashCode(e)</tt> recursively if <tt>e</tt> is an array
     * of a reference type.  If <tt>a</tt> is <tt>null</tt>, this method
     * returns 0.
     *
     * @param the array whose deep-content-based hash code to compute
     * @return a deep-content-based hash code for the array <tt>a</tt>
     * @see #hashCode(Object[])
     */
    public static int deepHashCode(Object a[]);
    
    
    <b>// toString methods</b>

    /**
     * Returns a string representation of the contents of the specified array.
     * The string representation consists of a list of the array's elements,
     * enclosed in square brackets (<tt>"[]"</tt>).  Adjacent elements are
     * separated by the characters <tt>", "</tt> (a comma followed by a
     * space).  Elements are converted to strings as by
     * <tt>String.valueOf(long)</tt>.  Returns <tt>"null"</tt> if <tt>a</tt>
     * is <tt>null</tt>.
     *
     * @param the array whose string representation to return
     * @return a string representation of the array <tt>a</tt>
     */
    public static String toString(long[] a);
    
    // Analogous methods for each of the other seven primitive types (not shown)
    // plus these two for Object:
    
    /**
     * Returns a string representation of the contents of the specified array.
     * If the array contains other arrays as elements, they are converted to
     * strings by the {@link Object#toString} method inherited from
     * <tt>Object</tt>, which describes their <i>identities</i> rather than
     * their contents.  It is therefore acceptable to invoke this method on an
     * array that contains itself as an element, either directly or indirectly
     * through one or more levels of arrays.
     *
     * The value returned by this method is equal to the value that would
     * be returned by <tt>Arrays.asList(a).toString()</tt>, unless <tt>a</tt>
     * is <tt>null</tt>, in which case <tt>"null"</tt> is returned.
     *
     * @param the array whose string representation to return
     * @return a string representation of the array <tt>a</tt>
     * @see #deepToString()
     */
    public static String toString(Object[] a);
    
    /**
     * Returns a string representation of the "deep contents" of the specified
     * array.  If the array contains other arrays as elements, the string
     * representation contains their contents and so on, ad infinitum.  If
     * the specified array contains itself as an element, the element will be
     * converted to the string <tt>"(this array)"</tt>.  If, however, the
     * specified array contains an indirect reference to itself through one or
     * more levels of arrays, the behavior of this method is undefined.
     *
     * The string representation consists of a list of the array's
     * elements, enclosed in square brackets (<tt>"[]"</tt>).  Adjacent
     * elements are separated by the characters <tt>", "</tt> (a comma
     * followed  by a space).  Elements are converted to strings as by
     * <tt>String.valueOf(Object)</tt>, unless they are themselves
     * arrays.
     *
     * If an element <tt>e</tt> is an array of a primitive type, it is
     * converted to a string as by invoking the appropriate overloading of
     * <tt>Arrays.toString(e)</tt>.  If an element <tt>e</tt> is an array of a
     * reference type, it is converted to a string as by invoking
     * <tt>Arrays.deepToString(e)</tt> recursively, unless <tt>e</tt>
     * is the specified array itself (in which case it is converted to
     * the string <tt>"(this array)"</tt>).
     *
     * This method returns <tt>"null"</tt> if the specified array
     * is <tt>null</tt>.
     *
     * @param the array whose string representation to return
     * @return a string representation of the array <tt>a</tt>
     * @see #toString(Object[])
     */
    public static String deepToString(Object[] a);
    
    <b>// This equals method goes with deepHashCode.  (The other eight equals methods
    // are already in java.util.Arrays.)</b>
    
    /**
     * Returns <tt>true</tt> if the two specified arrays are <i>deeply
     * equal</i> to one another.  Unlike the @link{#equals{Object[],Object[])
     * method, this method is appropriate for use with nested arrays of
     * arbitrary depth.
     *
     * Two array references are considered deeply equal if both
     * are <tt>null</tt>, or if they refer to arrays that contain the same
     * number of elements and all corresponding pairs of elements in the two
     * arrays are deeply equal.
     *
     * Two possibly <tt>null</tt> elements <tt>e1</tt> and <tt>e2</tt> are
     * deeply equal if any of the following conditions hold:
     * 
     *    <tt>e1</tt> and <tt>e2</tt> are both arrays of object reference
     *    types, and <tt>Arrays.deepEquals(e1, e2) would return true</tt>
     *
     *    <tt>e1</tt> and <tt>e2</tt> are arrays of the same primitive
     *    type, and the appropriate overloading of
     *    <tt>Arrays.equals(e1, e2)</tt> would return true.
     *
     *    <tt>e1 == e2</tt>
     *
     *    <tt>e1.equals(e2)</tt> would return true.
     * 
     * Note that this definition permits <tt>null</tt> elements at any depth.
     *
     * If either of the specified arrays contain themselves as elements
     * either directly or indirectly through one or more levels of arrays,
     * the behavior of this method is undefined.
     *
     * @param a1 one array to be tested for equality
     * @param a2 the other array to be tested for equality
     * @return <tt>true</tt> if the two arrays are equal
     * @see #equals(Object[],Object[])
     */
    public static boolean deepEquals(Object[] a1, Object[] a2);
</pre>

<h2>VIII. Annotation Type Evolution (Binary Compatibility)</h2>

This section discusses what happens when you modify an annotation type
declaration.  The short summary is that it's fine to add members with
defaults; to add defaults for members that previously lacked them; or to add
targets to annotation types.  Other changes may cause trouble of varying
degrees.

<h3>Adding an Annotation Type Member</h3>

Whenever a member is added to an annotation type for which compiled (or serialized)
annotations exist, the new member should be given a default.  If it is,
all existing sources will continue to compile and all compiled annotations
will continue to function properly.  If a program attempts, using the revised
annotation interface, to read the new member from an annotation that was
compiled (or serialized) when the annotation type lacked this member, the default
value will be returned. If no default exists, invoking the accessor for this
member will throw a <tt>java.lang.IncompleteAnnotationError</tt>:
<pre>
/**
 * Thrown to indicate that a program has attempted to access a member of
 * an annotation type that was added to the annotation type definition after
 * the annotation was compiled (or serialized).  This error will not be thrown
 * if the new member has a default value.
 */
public class IncompleteAnnotationError extends IncompatibleClassChangeError {
    /**
     * Constructs an <tt>IncompleteAnnotationError</tt> to indicate that
     * the named member was missing from the specified annotation type.
     *
     * @param annotationType the <tt>Class</tt> object for the annotation type
     * @param memberName the name of the missing member
     */
    public IncompleteAnnotationError(Class annotationType, String memberName) { }

    /**
     * Returns the <tt>Class</tt> object for the annotation type with the
     * missing member.
     *
     * @return the <tt>Class</tt> object for the annotation type with the
     *     missing member
     */
    public Class annotationType() { }

    /**
     * Returns the name of the missing member.
     *
     * @return the name of the missing member
     */
    public Class memberName() { }
}
</pre>

<h3>Removing an Annotation Type Member</h3>

Removing a member from an annotation type will cause compilation errors for existing
sources containing annotations with a value for the missing member.
Class files that invoke the accessor for the removed member will fail at
runtime with a <tt>java.lang.NoSuchMethodError</tt>.  Removing a member from
an annotation type will not, however, cause problems when reading annotations
of the revised type that were compiled (or serialized) while the removed
member was still present; the value for the deleted member will be
silently discarded.

<h3>Changing the Type of an Annotation Type Member</h3>

A member's type must not be changed if compiled (or serialized) annotations
exist.  Attempting to read the annotation type using the revised interface will
result in an <tt>AnnotationTypeMismatchError</tt>:
<pre>
/**
 * Thrown to indicate that a program has attempted to access a member of
 * an annotation type whose type has changed after the annotation was compiled
 * (or serialized).
 */
public class AnnotationTypeMismatchError extends IncompatibleClassChangeError {
    /**
     * Constructs an <tt>AnnotationTypeMismatchError</tt> to indicate that
     * the type of the named member has changed.
     *
     * @param annotationType the <tt>Class</tt> object for the annotation type
     * @param memberName the name of the incorrectly typed member
     */
    public AnnotationTypeMismatchError(Class annotationType, String memberName) { }

    /**
     * Returns the <tt>Class</tt> object for the annotation type with the
     * incorrectly typed member.
     *
     * @return the <tt>Class</tt> object for the annotation type with the
     *    incorrectly typed member
     */
    public Class annotationType() { }

    /**
     * Returns the name of the incorrectly typed member.
     *
     * @return the name of the incorrectly typed member
     */
    public Class memberName() { }
}
</pre>
Changing the type of an annotation type member may cause compilation errors for
existing classes that contain annotations for the type, or that invoke the
accessor for the member.  Class files that invoke the accessor will fail at
runtime with a <tt>java.lang.NoSuchMethodError</tt>.

<h3>Adding and Removing Defaults</h3>

It is always acceptable to add a default to a preexisting member.  It is
rarely acceptable to remove a default.  Sources that depended on the default
will no longer compile. Attempts to read the member from a compiled (or
serialized) annotation that relied on the default will fail:  the accessor
will throw an <tt>IncompleteAnnotationError</tt>.

<h3>Adding and Removing Potential Targets</h3>

It is fine to add one or more potential targets to an existing annotation type
using the <tt>Target</tt> meta-annotation type.  If, however, one or more
targets are removed, source files attempting to annotate removed targets
will no longer compile.  Class files containing annotations on the removed
targets will behave as if those annotations were not present.

<h3>Changing Annotation Type Retention Policy</h3>
Adding a <tt>Retention</tt> meta-annotation when none was present
has the following effect:  If the value of the meta-annotation is
<tt>SOURCE</tt>, class files containing annotations for the type will behave
as if those annotations were not present.  If the value of the meta-annotation
is <tt>CLASS</tt>, the behavior will be unaffected.  If the value of the
meta-annotation is <tt>RUNTIME</tt>, annotations for the type will continue to
behave as if the meta-annotation were not present.  In other words, such
annotations will not propagate from the class file to the virtual machine if
the class file was generated before the Retention meta-annotation was added.

<p>Changing the retention policy from <tt>SOURCE</tt> to <tt>CLASS</tt> or
<tt>RUNTIME</tt> will behave as expected: existing class files will behave as
if their sources contained no annotations for the type in question.  The
source must be recompiled to propagate the annotation into the class file.
Changing the retention policy from  <tt>RUNTIME</tt> to <tt>CLASS</tt>
or <tt>SOURCE</tt> works fine.  (If the new value of the meta-annotation is
<tt>SOURCE</tt>, class files containing annotations for the type
will behave as if those annotations were not present; if the new value is
<tt>CLASS</tt>, the these annotations will not be readable at runtime.)
Changing the retention policy from <tt>CLASS</tt> to <tt>SOURCE</tt> or
<tt>RUNTIME</tt> behaves exactly as adding a <tt>SOURCE</tt> or
<tt>RUNTIME</tt> meta-annotation when none was present.

<a name="class_file"></a>
<h2>IX. Class File Format for Annotations</h2>

This section describes five new <i>predefined attributes</i> that are used to
represent annotations in the class file: <tt>RuntimeVisibleAnnotations</tt>,
<tt>RuntimeInvisibleAnnotations</tt>, 
<tt>RuntimeVisibleParameterAnnotations</tt>, 
<tt>RuntimeInvisibleParameterAnnotations</tt>, and 
<tt>AnnotationDefault</tt>.  The material contained in this
section is destined for inclusion in Section 4.7 of the Java Virtual Machine
Specification (JVMS).

<h3>The <tt>RuntimeVisibleAnnotations</tt> attribute</h3>

The <tt>RuntimeVisibleAnnotations</tt> attribute is a variable length
attribute in the <tt>attributes</tt> table of the <tt>ClassFile</tt>,
<tt>field_info</tt>, and <tt>method_info</tt> structures.  The
<tt>RuntimeVisibleAnnotations</tt> attribute records runtime-visible Java
programming language annotations on the corresponding class, method, or field.
Each <tt>ClassFile</tt>, <tt>field_info</tt>, and <tt>method_info</tt>
structure may contain at most one <tt>RuntimeVisibleAnnotations</tt>
attribute, which records <i>all</i> the runtime-visible Java programming
language annotations on the corresponding program element.  The JVM must make
these annotations available so they can be returned by the appropriate
reflective APIs.

<p>The <tt>RuntimeVisibleAnnotations</tt> attribute has the following format:
<pre>
    RuntimeVisibleAnnotations_attribute {
        u2 attribute_name_index;
        u4 attribute_length;
        u2 num_annotations;
        annotation annotations[num_annotations];
    }
</pre>

The items of the <tt>RuntimeVisibleAnnotations</tt> structure are as follows:
<dl>
<dt><tt>attribute_name_index</tt><dd>
  The value of the <tt>attribute_name_index</tt> item must be a valid index into the constant_pool table. The constant_pool entry at that index must be a <tt>CONSTANT_Utf8_info</tt> structure representing the string <tt>"RuntimeVisibleAnnotations"</tt>.
<dt><tt>attribute_length</tt><dd>
  The value of the <tt>attribute_length</tt> item indicates the length of the attribute, excluding the initial six bytes. The value of the <tt>attribute_length</tt> item is thus dependent on the number of runtime-visible annotations represented by the structure, and their values.
<dt><tt>num_annotations</tt><dd>
  The value of the <tt>num_annotations</tt> item gives the number of runtime-visible annotations represented by the structure.  Note that a maximum of 65535 runtime-visible Java programming language annotations may be directly attached to a program element.

<dt><tt>annotations</tt><dd>
Each value of the <tt>annotations</tt> table represents a single runtime-visible annotation on a program element.
</dl>

<p>The <tt>annotation</tt> structure has the following format:
<pre>
    annotation {
        u2    type_index;
        u2    num_member_value_pairs;
        {    u2    member_name_index;
             member_value value;
        }    member_value_pairs[num_member_value_pairs];
    }
</pre>

<p>The items of the <tt>annotation</tt> structure are as follows:

<dl>
<dt><tt>type_index</tt><dd>
  The value of the <tt>type_index</tt> item must be a valid index into the constant_pool table. The constant_pool entry at that index must be a <tt>CONSTANT_Class_info</tt> structure representing the annotation interface corresponding to the annotation represented by this <tt>annotation</tt> structure.

<dt><tt>num_member_value_pairs</tt><dd>
  The value of the <tt>num_member_value_pairs</tt> item gives the number of member-value pairs in the annotation represented by this <tt>annotation</tt> structure.  Note that a maximum of 65535 member-value pairs may be contained in a single annotation.

<dt><tt>member_value_pairs</tt><dd>
  Each value of the <tt>member_value_pairs</tt> table represents a single
  member-value pair in the annotation represented by this <tt>annotation</tt> structure.  Each <tt>member_value_pairs</tt> entry contains the following two items:
<dl>
<dt><tt>member_name_index</tt><dd>
  The value of the <tt>member_name_index</tt> item must be a valid index into
  the constant_pool table. The constant_pool entry at that index must be a
  <tt>CONSTANT_Utf8_info</tt> structure representing the name of the annotation type
 member corresponding to this <tt>member_value_pairs</tt> entry.

<dt><tt>value</tt><dd>
The <tt>value</tt> item represents the value in the member-value pair
represented by this <tt>member_value_pairs</tt> entry.
</dl>
</dl>

<h3>The <tt>member_value</tt> structure</h3>

<p>The <tt>member_value</tt> structure is a discriminated union representing
the value of a member-value pair.  It is used to represent values
in all class file attributes that describe annotations (
<tt>RuntimeVisibleAnnotations</tt>, <tt>RuntimeInvisibleAnnotations</tt>,
<tt>RuntimeVisibleParameterAnnotations</tt>, and
<tt>RuntimeInvisibleParameterAnnotations</tt>).

<p>The <tt>member_value</tt> structure has the following format:
<pre>
    member_value {
        u1 tag;
        union {
            u2   const_value_index;
            {
                u2   type_name_index;
                u2   const_name_index;
            } enum_const_value;
            u2   class_info_index;
            annotation annotation_value; 
            {
                u2    num_values;
                member_value values[num_values];
            } array_value;
        } value;
    }
</pre>

<p>The items of the <tt>member_value</tt> structure are as follows:
<dl>
<dt><tt>tag</tt><dd>
The <tt>tag</tt> item indicates the member type of this member-value pair.  The letters <tt>'B', 'C', 'D', 'F', 'I', 'J', 'S', and 'Z'</tt> indicate a primitive type.  These letters are interpreted as <i>BaseType</i> characters (Table 4.2).  The other legal values for <tt>tag</tt> are listed with their interpretations in this table:

<TABLE border="1">
<TR><TH><tt>tag</tt> value<TH>Member Type
<TR><TD><tt>'s'</tt> <TD><tt>String</tt>
<TR><TD><tt>'e'</tt> <TD>enum constant
<TR><TD><tt>'c'</tt> <TD>class
<TR><TD><tt>'@'</tt> <TD>annotation type
<TR><TD><tt>'['</tt> <TD>array
</TABLE>

<dt><tt>value</tt><dd>
The <tt>value</tt> item represents the value of this annotation element.  This item is a union.  The <tt>tag</tt> item, above, determines which item of the union is to be used:

<dl>
<dt><tt>const_value_index</tt><dd>
The <tt>const_value_index</tt> item is used if the <tt>tag</tt> item is one of
<tt>'B', 'C', 'D', 'F', 'I', 'J', 'S', 'Z', or 's'</tt>.  The value of the
<tt>const_value_index</tt> item must be a valid index into the constant_pool
table.  The constant_pool entry at that index must be of the correct entry
type for the field type designated by the <tt>tag</tt> item, as specified in
table 4.6, with one exception: if the tag is <tt>'s'</tt>, the 
the value of the <tt>const_value_index</tt> item must be the index of a
<tt>CONSTANT_Utf8</tt> structure, rather than a <tt>CONSTANT_String</tt>.

<dt><tt>enum_const_value</tt><dd>
The <tt>enum_const_value</tt> item is used if the <tt>tag</tt> item is <tt>'e'</tt>.  The <tt>enum_const_value</tt> item consists of the following two items:
<dl>
<dt><tt>type_name_index</tt><dd>
  The value of the <tt>type_name_index</tt> item must be a valid index
  into the constant_pool table. The constant_pool entry at that index must be
  a <tt>CONSTANT_Utf8_info</tt> structure representing the <i>binary name</i>
  (JLS 13.1) of the type of the enum constant represented by this
  <tt>member_value</tt> structure. 
<dt><tt>const_name_index</tt><dd>
  The value of the <tt>const_name_index</tt> item must be a valid index
  into the constant_pool table. The constant_pool entry at that index must be
  a <tt>CONSTANT_Utf8_info</tt> structure representing the simple name
  of the enum constant represented by this <tt>member_value</tt> structure. 
</dl>

<dt><tt>class_info_index</tt><dd>
The <tt>class_info_index</tt> item is used if the <tt>tag</tt> item is <tt>'c'</tt>.  The <tt>class_info_index</tt> item must be a valid index into the constant_pool table. The constant_pool entry at that index must be a <tt>CONSTANT_Class_info</tt> structure representing the class represented by this <tt>member_value</tt> structure.

<dt><tt>annotation_value</tt><dd>
The <tt>annotation_value</tt> item is used if the <tt>tag</tt> item is <tt>'@'</tt>.  The <tt>member_value</tt> structure represents a "nested" annotation.

<dt><tt>array_value</tt><dd>
The <tt>array_value</tt> item is used if the <tt>tag</tt> item is <tt>'['</tt>.    The <tt>array_value</tt> item consists of the following two items:
<dl>
<dt><tt>num_values</tt><dd>
  The value of the <tt>num_values</tt> item gives the number of elements in
  the array-typed value represented by this <tt>member_value</tt> structure.
  Note that a maximum of 65535 elements are permitted in an array-typed member
  value.

<dt><tt>values</tt><dd>
Each element of the <tt>values</tt> table gives the value of an element of the array-typed value represented by this <tt>member_value</tt> structure.
</dl>
</dl>
</dl>

<h3>The <tt>RuntimeInvisibleAnnotations</tt> attribute</h3>

The <tt>RuntimeInvisibleAnnotations</tt> attribute is similar to the  <tt>RuntimeVisibleAnnotations</tt> attribute, except that the annotations represented by a <tt>RuntimeInvisibleAnnotations</tt> attribute must <i>not</i> be made available for return by reflective APIs, unless the JVM has been instructed to retain these annotations via some implementation-specific mechanism such as a command line flag.  In the absence of such instructions, the JVM ignores this attribute.

<p>The <tt>RuntimeInvisibleAnnotations</tt> attribute is a variable length
attribute in the <tt>attributes</tt> table of the <tt>ClassFile</tt>,
<tt>field_info</tt>, and <tt>method_info</tt> structures.  The
<tt>RuntimeInvisibleAnnotations</tt> attribute records runtime-invisible Java
programming language annotations on the corresponding class, method, or field.
Each <tt>ClassFile</tt>, <tt>field_info</tt>, and <tt>method_info</tt>
structure may contain at most one <tt>RuntimeInvisibleAnnotations</tt>
attribute, which records <i>all</i> the runtime-invisible Java programming
language annotations on the corresponding program element.

<p>The <tt>RuntimeInvisibleAnnotations</tt> attribute has the following format:
<pre>
    RuntimeInvisibleAnnotations_attribute {
        u2 attribute_name_index;
        u4 attribute_length;
        u2 num_annotations;
        annotation annotations[num_annotations];
    }
</pre>

The items of the <tt>RuntimeInvisibleAnnotations</tt> structure are as follows:
<dl>
<dt><tt>attribute_name_index</tt><dd>
  The value of the <tt>attribute_name_index</tt> item must be a valid index into the constant_pool table. The constant_pool entry at that index must be a <tt>CONSTANT_Utf8_info</tt> structure representing the string <tt>"RuntimeInvisibleAnnotations"</tt>.
<dt><tt>attribute_length</tt><dd>
  The value of the <tt>attribute_length</tt> item indicates the length of the attribute, excluding the initial six bytes. The value of the <tt>attribute_length</tt> item is thus dependent on the number of runtime-invisible annotations represented by the structure, and their values.
<dt><tt>num_annotations</tt><dd>
  The value of the <tt>num_annotations</tt> item gives the number of runtime-invisible annotations represented by the structure.  Note that a maximum of 65535 runtime-invisible Java programming language annotations may be directly attached to a program element.
<dt><tt>annotations</tt><dd>
Each value of the <tt>annotations</tt> table represents a single runtime-invisible annotation on a program element.
</dl>

<h3>The <tt>RuntimeVisibleParameterAnnotations</tt> attribute</h3>

The <tt>RuntimeVisibleParameterAnnotations</tt> attribute is a variable length
attribute in the <tt>attributes</tt> table of the <tt>method_info</tt> structure.  The <tt>RuntimeVisibleParameterAnnotations</tt> attribute records runtime-visible Java programming language annotations on the parameters of the corresponding method.  Each <tt>method_info</tt> structure may contain at most one <tt>RuntimeVisibleParameterAnnotations</tt> attribute, which records <i>all</i> the runtime-visible Java programming language annotations on the parameters of the corresponding method.  The JVM must make these annotations available so they can be returned by the appropriate reflective APIs.

<p>The <tt>RuntimeVisibleParameterAnnotations</tt> attribute has the following format:
<pre>
    RuntimeVisibleParameterAnnotations_attribute {
        u2 attribute_name_index;
        u4 attribute_length;
        u1 num_parameters;
        {
            u2 num_annotations;
            annotation annotations[num_annotations];
        } parameter_annotations[num_parameters];
    }
</pre>

The items of the <tt>RuntimeVisibleParameterAnnotations</tt> structure are as follows:
<dl>
<dt><tt>attribute_name_index</tt><dd>
  The value of the <tt>attribute_name_index</tt> item must be a valid index into the constant_pool table. The constant_pool entry at that index must be a <tt>CONSTANT_Utf8_info</tt> structure representing the string <tt>"RuntimeVisibleParameterAnnotations"</tt>.
<dt><tt>attribute_length</tt><dd>
  The value of the <tt>attribute_length</tt> item indicates the length of the attribute, excluding the initial six bytes. The value of the <tt>attribute_length</tt> item is thus dependent on the number of parameters, the number of runtime-visible annotations on each parameter, and their values.

<dt><tt>num_parameters</tt><dd>
  The value of the <tt>num_parameters</tt> item gives the number of parameters of the method represented by the <tt>method_info</tt> structure on which the annotation occurs.  (This duplicates information that could be extracted from the method descriptor.)

<dt><tt>parameter_annotations</tt><dd>
  Each value of the <tt>parameter_annotations</tt> table represents all of the runtime-visible annotations on a single parameter.  The sequence of values in the table corresponds to the sequence of parameters in the method signature.  Each <tt>parameter_annotations</tt> entry contains the following two items:
<dl>
<dt><tt>num_annotations</tt><dd>
The value of the <tt>num_annotations</tt> item indicates the number of runtime-visible annotations on the parameter corresponding to the sequence number of this <tt>parameter_annotations</tt> element.

<dt><tt>annotations</tt><dd>
Each value of the <tt>annotations</tt> table represents a single runtime-visible  annotation on the parameter corresponding to the sequence number of this <tt>parameter_annotations</tt> element.
</dl>
</dl>

<h3>The <tt>RuntimeInvisibleParameterAnnotations</tt> attribute</h3>

The <tt>RuntimeInvisibleParameterAnnotations</tt> attribute is similar to the  <tt>RuntimeVisibleParameterAnnotations</tt> attribute, except that the annotations represented by a <tt>RuntimeInvisibleParameterAnnotations</tt> attribute must <i>not</i> be made available for return by reflective APIs, unless the JVM has specifically been instructed to retain these annotations via some implementation-specific mechanism such as a command line flag.  In the absence of such instructions, the JVM ignores this attribute.

<p>The <tt>RuntimeInvisibleParameterAnnotations</tt> attribute is a variable length attribute in the <tt>attributes</tt> table of the <tt>method_info</tt> structure.  The <tt>RuntimeInvisibleParameterAnnotations</tt> attribute records runtime-invisible Java programming language annotations on the parameters of the corresponding method.  Each <tt>method_info</tt> structure may contain at most one <tt>RuntimeInvisibleParameterAnnotations</tt> attribute, which records <i>all</i> the runtime-invisible Java programming language annotations on the parameters of the corresponding method.

<p>The <tt>RuntimeInvisibleParameterAnnotations</tt> attribute has the following format:
<pre>
    RuntimeInvisibleParameterAnnotations_attribute {
        u2 attribute_name_index;
        u4 attribute_length;
        u1 num_parameters;
        {
            u2 num_annotations;
            annotation annotations[num_annotations];
        } parameter_annotations[num_parameters];
    }
</pre>

The items of the <tt>RuntimeInvisibleParameterAnnotations</tt> structure are as follows:
<dl>
<dt><tt>attribute_name_index</tt><dd>
  The value of the <tt>attribute_name_index</tt> item must be a valid index into the constant_pool table. The constant_pool entry at that index must be a <tt>CONSTANT_Utf8_info</tt> structure representing the string <tt>"RuntimeInvisibleParameterAnnotations"</tt>.
<dt><tt>attribute_length</tt><dd>
  The value of the <tt>attribute_length</tt> item indicates the length of the attribute, excluding the initial six bytes. The value of the <tt>attribute_length</tt> item is thus dependent on the number of parameters, the number of runtime-invisible annotations on each parameter, and their values.

<dt><tt>num_parameters</tt><dd>
  The value of the <tt>num_parameters</tt> item gives the number of parameters of the method represented by the <tt>method_info</tt> structure on which the annotation occurs.  (This duplicates information that could be extracted from the method descriptor.)

<dt><tt>parameter_annotations</tt><dd>
  Each value of the <tt>parameter_annotations</tt> table represents all of the runtime-invisible annotations on a single parameter.  The sequence of values in the table corresponds to the sequence of parameters in the method signature.  Each <tt>parameter_annotations</tt> entry contains the following two items:
<dl>
<dt><tt>num_annotations</tt><dd>
The value of the <tt>num_annotations</tt> item indicates the number of runtime-invisible annotations on the parameter corresponding to the sequence number of this <tt>parameter_annotations</tt> element.

<dt><tt>annotations</tt><dd>
Each value of the <tt>annotations</tt> table represents a single runtime-invisible  annotation on the parameter corresponding to the sequence number of this <tt>parameter_annotations</tt> element.
</dl>
</dl>

<h3>The <tt>AnnotationDefault</tt> attribute</h3>

The <tt>AnnotationDefault</tt> attribute is a variable length attribute in
the <tt>attributes</tt> table of certain <tt>method_info</tt> structures,
namely those representing members of annotation types.  The
<tt>AnnotationDefault</tt> attribute records the default value for the
member represented by the <tt>method_info</tt> structure.
Each <tt>method_info</tt> structures representing a member of an annotation
types may contain at most one <tt>AnnotationDefault</tt> attribute.
The JVM must make this default value available so it can be applied by
appropriate reflective APIs.

<p>The <tt>AnnotationDefault</tt> attribute has the following format:
<pre>
    AnnotationDefault_attribute {
        u2 attribute_name_index;
        u4 attribute_length;
        member_value default_value;
    }
</pre>

The items of the <tt>AnnotationDefault</tt> structure are as follows:
<dl>
<dt><tt>attribute_name_index</tt><dd>
  The value of the <tt>attribute_name_index</tt> item must be a valid index
  into the constant_pool table. The constant_pool entry at that index must be
  a <tt>CONSTANT_Utf8_info</tt> structure representing the string
  <tt>"AnnotationDefault"</tt>.

<dt><tt>attribute_length</tt><dd>
  The value of the <tt>attribute_length</tt> item indicates the length of the
  attribute, excluding the initial six bytes. The value of the
  <tt>attribute_length</tt> item is thus dependent on the default value.

<dt><tt>default_value</tt><dd>
  The <tt>default_value</tt> item represents the default value of the
  annotation type member whose default value is represented by this
  <tt>AnnotationDefault</tt> attribute.
</dl>

<h3>Package-level Annotations</h3>
The following information presumably belongs in Chapter 7 of the JVMS,
"Compiling for the Java Virtual Machine."

<p>Package-level annotations are a special case.  When the compiler encounters
an annotated package declaration, it must emit a synthetic interface named
<i>package-name</i><tt>.package-info</tt> with no superinterfaces or members
(exculding those methods implicitly declared as per JLS 9.2).  The synthetic
interface has the default access level ("package-private").  The package-level
annotations are stored in the <tt>RuntimeVisibleAnnotations</tt> and
<tt>RuntimeInvisibleAnnotations</tt> attributes of the <tt>ClassFile</tt>
structure.

<h2>
<a name="arms_length">Appendix I. Reading Annotations "at Arm's Length"</a>
</h2>

<p>The Doclet API is not currently part of any standard.
This (non-normative) appendix shows how the Doclet API will be modified to
support program annotations.  Note that this API is rather low-level: it
ignores member defaults and annotation inheritance.  This is consistent with
rest of the Doclet API.

<p>The following interfaces are added to <tt>com.sun.javadoc</tt>:
<pre>
/**
 * Represents an annotation.
 * An annotation associates a value with each member of an annotation type.
 */
public interface AnnotationDesc {
    /**
     * Returns the annotation type of this annotation.
     *
     * @return the annotation type of this annotation
     */
    AnnotationTypeDoc annotationType();

    /**
     * Returns this annotation's members and their values.
     * Only those explicitly present in the annotation are
     * included, not those assuming their default values.
     * Returns an empty array if there are none.
     *
     * @return this annotation's members and their values
     */
    MemberValuePair[] memberValues();


    /**
     * Represents an association between an annotation type member
     * and one of its values.
     */
    public interface MemberValuePair {

	/**
	 * Returns the annotation type member.
	 *
	 * @return the annotation type member
	 */
	AnnotationTypeMemberDoc member();

	/**
	 * Returns the value associated with the annotation type member.
	 *
	 * @return the value associated with the annotation type member
	 */
	AnnotationValue value();
    }
}


/**
 * Represents an annotation type.
 */
public interface AnnotationTypeDoc extends ClassDoc {

    /**
     * Returns the members of this annotation type.
     * Returns an empty array if there are none.
     *
     * @return the members of this annotation type
     */
    AnnotationTypeMemberDoc[] members();
}


/**
 * Represents a member of an annotation type.
 */
public interface AnnotationTypeMemberDoc extends MethodDoc {

    /**
     * Returns the default value of this member.
     * Returns null if this member has no default.
     *
     * @return the default value of this member
     */
    AnnotationValue defaultValue();
}

/**
 * Represents a value of an annotation type member.
 */
public interface AnnotationValue {

    /**
     * Returns the value.
     * The type of the returned object is one of the following:
     *
     *    - a wrapper class for a primitive type
     *    - <code>String</code>
     *    - <code>ClassDoc</code>
     *    - <code>FieldDoc</code> (representing an enum constant)
     *    - <code>AnnotationDesc</code>
     *    - <code>AnnotationValue[]</code>
     *
     * @return the value
     */
    Object value();

    /**
     * Returns a string representation of the value.
     *
     * @return the text of a Java language annotation value expression
     *		whose value is the value of this annotation type member
     */
    String toString();
}
</pre>

Several existing doclet interfaces are modified as follows:
<pre>
========================================
Doc
========================================
Add methods:

    /**
     * Is this Doc item an annotation type?
     *
     * @return true if it represents an annotation type
     */
    boolean isAnnotationType();

    /**
     * Is this Doc item an annotation type member?
     *
     * @return true if it represents an annotation type member
     */
    boolean isAnnotationTypeMember();


========================================
PackageDoc
========================================
Add methods:

    /**
     * Get included annotation types in this package.
     *
     * @return included annotation types in this package
     */
    AnnotationTypeDoc[] annotationTypes();

    /**
     * Get the annotations of this package.
     * Return an empty array if there are none.
     *
     * @return the annotations of this package
     */
    AnnotationDesc[] annotations();

Clarify that interfaces() excludes annotation types.


========================================
ClassDoc
========================================
Clarify that methods() and methods(boolean) exclude annotation type members.


========================================
Parameter
========================================
Add method:

    /**
     * Get the annotations of this parameter.
     * Return an empty array if there are none.
     *
     * @return the annotations of this parameter
     */
    AnnotationDesc[] annotations();


========================================
ProgramElementDoc
========================================
Add method:

    /**
     * Get the annotations of this program element.
     * Return an empty array if there are none.
     *
     * @return the annotations of this program element
     */
    AnnotationDesc[] annotations();

Clarify that the string returned by modifiers() does not include annotations.


========================================
Type
========================================
Add method:

    /**
     * Return this type as an <code>AnnotationTypeDoc</code> if it represents
     * an annotation type.
     *
     * @return an <code>AnnotationTypeDoc</code> if the type is an annotation
     *         type, or null if it is not
     */
    AnnotationTypeDoc asAnnotationTypeDoc();
</pre>

<h2>Appendix II. Design FAQ</h2>
This collection of frequently asked questions concerning the design of
the program annotation facility is meant to serve as a design rationale.

<h3>Annotation Types</h3>

<ol>
<li>
<b>Why didn't you use a new <tt>attribute</tt> keyword to declare annotation types?</b></li>
<p>Given the huge number of Java programs already in existence, there is a great advantage to providing source compatibility.  Many programs use <tt>attribute</tt> as an identifier, and those programs would no longer be legal.  If fact, it would not have been possible to do this, as it conflicts with <tt>javax.print.attribute</tt>.

<li>
<b>Why did you use the at-sign (<tt>@</tt>) to indicate an annotation rather
than brackets(<tt>[]</tt>)?</b></li>
<p>Two reasons: (1) It is reminiscent of Javadoc tags, a preexisting ad hoc
annotation facility in the Java programming language, and (2) It is mnemonic:
at = a[nnotation] t[ype].

<li><b>Why do you use method declaration syntax (<tt>String name();</tt>) to
declare attribute members instead of field syntax (<tt>String name;</tt>)?</b>
<p>Because annotation type declarations really do declare an interface
(which is used to access the annotations).  Thus, it makes sense that
annotation types and ordinary interfaces share a common declaration syntax.
Further, the field-like notation would be confusing because the semantics are
different from fields.  In particular, the default semantics are
different from field initialization semantics.
<li>
<b>Why don't you support attribute subtyping (where one attribute type extends another)?</b></li>
<p>It complicates the attribute type system, and makes it much more difficult to write "Specific Tools" (per the taxonomy in Section VI).

<li><b>Why is it illegal for an annotation type to contain a member of the same type?</b></li>
<p>
At first glance it would appear that you could never annotate with such
a type, so the prohibition might seem unnecessary, but you can get
yourself into trouble if you also provide a default:
<pre>
@interface Foo {
    Foo foo() default @Foo;
}

@Foo int i;
</pre>
This is legal, but the resulting annotation is self-referential (or
infinite), as well as totally useless.

</ol>

<h3>Annotations</h3>


<ol>
<li>
<b>Why is it illlegal to use <tt>null</tt> as an annotation value?</b></li>
<p>It is consistent with the fact that <tt>null</tt> is not a compile-time
constant expression (JLS 15.28).  Also it's consistent with the proposal that
<tt>null</tt> is not a legal case label in a switch statement on an enum
expression.  It eliminates a behavioral difference between primitive
annotation members and reference type annotation members, and reduces the
likelihood of a <tt>NullPointerException</tt> at run time.

<li>
<b>Why is it illegal annotate a single element repeatedly with the same annotation type?</b></li>
<p>A similar effect is available by annotating once with an annotation type
whose sole member is of an array type.  The resulting system is simpler and
cleaner: you don't have to worry about whether you're going to get back a
single instance of the annotation type or multiple instances when you query an
annotation.  Also it's consistent with the usual restriction on modifiers.

<li>
<b>Why can't you annotate arbitrary program elements such as blocks and
individual statements?</b>
<p>This would greatly complicate the annotation syntax: We would have to
sacrifice the simplicity of saying that annotations are simply modifiers,
which can be used on declarations.

<li>
<b>Why is a MemberValue of a non-array and non-annotation type restricted to a
ConditionalExpression, rather than an Expression?</b></li>
<p>To eliminate a syntactic ambiguity involving assignment operators.
</ol>

<h3>Semantics</h3>

<ol>
<li>
<b>Why don't you put local variable annotations into the class file?</b></li>
<p>There's no place to put them.  The class file format does not describe or expose structure within a method.  If, in future, the class file format is redesigned to provide such structural information, this decision will be reconsidered.

<li>
<b>Why doesn't the <tt>Overrides</tt> annotation let you confirm that
you've overridden a method in an <i>interface</i> (as well as a superclass)?
</b>

<p>The compiler already tells you if you've failed to override an interface
method (assuming you implement the interface).  It would be redundant and
confusing to offer similar functionality with the <tt>Overrides</tt>
annotation.

</ol>

<h2>Appendix III. Usage Notes</h2>
Programmers using annotations should be aware that programs acquire
dependencies on any annotation types they use, just as they acquire
dependencies on libraries.  In order to ensure portability, programmers may
elect to avoid using proprietary annotation types.

<h2>Appendix IV. Implementation Notes</h2>
The classes used to represent annotations are created at run time using
dynamic proxies (see java.lang.reflect.Proxy).

<h2>Appendix V. Issues</h2>

Some people have expressed concern over the fact that annotating a program
ties you to the annotation type, to the extent that you can't even compile the
annotated program if the class file for the annotation type is unavailable.
Annotations are no different in this respect from method invocations or field
accesses: if you use a library, the library must be present in order to
compile your program.

<p>For many annotations, this behavior is exactly what you want, as the
annotation results in the production of some artifact that is required to run
the program (such as an additional source file, or an XML document).  Some
annotations, however, are merely "structured comments," which are not intended
to have any affect on the running program.  For example, a UML modeling tool
might annotate program elements with model information for its own use.  If
the compiler knew that a given annotation were of this character, it could
safely ignore the annotation even if the class file for its annotation type
were unavailable.  This would allow people to compile the program even if they
did not have access to the class file for the annotation type.

<p>Unfortunately there is no way to indicate that a given annotation type is of
this character.  It cannot be done with a meta-annotation, as the compiler
cannot read the meta-annotation if it does not have access to the annotation
type.

<p>There are other alternatives.  For example, we could provide a second
annotation syntax (say, <tt>@@(a=1, b=3)</tt>) that indicates to the compiler
that an  annotation can be ignored if its class file is not present.
However, this places the decision as to whether an annotation should be
ignored in the hands of the annotater, rather than the annotation type author.
It should be up to the author of an annotation type to decide whether
annotations of that type can be safely ignored.

<p>A similar idea is to provide a compiler flag that instructs the compiler to
ignore certain annotations.  Again, this idea is questionable, as it places
the decision in the wrong hands.  This alternative, as well as the previous
one, could result in programs that simply did not run if the programmer
told the compiler to ignore critical metadata.

<p>Do you consider it problematic that annotations tie you to annotation types
in the same way that method invocations tie you libraries?  If so, can you
think of an acceptable solution to the problem?

<h2>Appendix VI. Change Log</h2>
<h3>Changes in Public Draft</h3>
<ol>

<li> Added this Appendix.

<li> Minor style change in annotation examples (Section III): added a newline
between the annotation and the the declaration it annotates for all but marker
annotation.

<li>Added examples of illegal circular annotation type declarations
to clarify what is prohibited.

<li>Added examples of permitted circular meta-annotations to clarify that
circularities of any length are permitted.

<li>Added a small amount of introductory text for each standard
meta-annotation type.

<li>Defined the term <i>runtime-visible</i> on first use.

<li>Added examples to Section VI ("Reading Annotations at Run Time").  This
completes the picture: now we have corresponding examples of annotation type
declaration, annotation, and reading annotations.

<li> Clarified the taxonomy of "annotation consumers" that begins Section VI to
indicate that "load" means "to load a class into the virtual machine," and to
define the term "at arm's length."

<li> Clarified that annotation inheritance applies only to superclasses, not to
implemented interfaces.

<li>Changed the name of <tt>ClassNotPresentException</tt> to
<tt>TypeNotPresentException</tt> to make more broadly applicable.

<li> Changed the name of the file in which package-level annotations are to be
placed from <tt>Package.java</tt> to <tt>package-info.java</tt>. 

<li> Eliminated the enum constant <tt>ENUM_CONSTANT</tt> from the enum type
<tt>ElementType</tt> (which is used in conjunction with the <tt>Target</tt>
meta-annotation).  An enum constant is an implicit field declaration, and the
<tt>FIELD</tt> constant is now specified to include enum constants.

<li> Clarified that the compiler must enforce annotation usage restrictions
specified with the <tt>Target</tt> meta-attribute.

<li>Added <tt>@Retention(RUNTIME)</tt> meta-annotation to annotation type
declarations for <tt>Target</tt> and <tt>Retention</tt>.

<li> Added Section VII ("Library Support").  It contains the marker interface
<tt>java.lang.Annotation</tt> (which now refines the contracts of
<tt>equals</tt> and <tt>toString</tt> to do the right thing), as well as
utility methods for manipulating arrays.

<li>Added explanatory text to Section IV ("Other Standard Annotation
Types") motivating the need for the <tt>Overrides</tt> annotation
type.

<li>Added <tt>@Retention(SOURCE)</tt> meta-annotation on <tt>Overrides</tt>
annotation type declaration.

<li> Moved the Class File Format to the end (Section IX) for readability.

<li>Modified "Changing Annotation Type Retention Policy" in Section VII
("Annotation Type Evolution") to indicate that adding a retention
policy of <tt>RUNTIME</tt> would not cause <tt>CLASS</tt>
annotations in existing class files to be readable at run time.

<li> Modified Appendix I (Reading Annotations "at Arm's Length") to reflect
the changes to the Doclet API that were actually implemented: filled in a few
holes in the original sketch, and brought a few names into line with Doclet
API conventions.

<li> Removed both issues from Appendix V, as there was near-unanimity on
both open issues among reviewers of the Community Draft.

<li>Added issue concerning "ignorable annotations."

<li>Added several entries to the FAQ.

<li>Modified the class file format of package-level metadata to indicate that
the synthetically generated type is an interface rather than a class, and to
fill in some details.

<li>Minor fixups to <tt>travelThroughTime</tt> example annotation and
<tt>Inherits</tt> FAQ as per Eamonn's letter.

<li>Added minor clarifications as per Doug's letter.

<li>Eliminated restriction on fields and nested class, interface, enum, or
annotation type declarations within annotation type declarations.

<li>Reordered list of parts at the end of section I

<li>Moved section VIII after section IV.

<li>Corrected lots of typos that Simon found

<li>Removed sentence from Appendix I that said <tt>isInterface()</tt> returns
false for annotation types.

<li>Added boldface warning on illegal <tt>Target</tt> annotation example as per
Cedric's request.

<li>Clarified the manner in which the AnnotatedElement API could be used by
"specific tools."
</ol>

<p><font size="-2">Copyright 2002-2003 Sun Microsystems, Inc., 901 San Antonio
Road, Palo Alto, California 94303 U.S.A. All rights reserved.</font>
</body></html>
